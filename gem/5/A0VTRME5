Áôº‰ø°‰∫∫: amaki.bbs@luna.twbbs.org (ÂçàË¶∫Áæä) ÁúãÊùø: plan
Ê®ô  È°å: [‰øÆÊ≠£]Á´ôÈï∑ÊîπIDË∑üÊîπuserno‰πüË¶ÅÈ†Ü‰æøÊîπ.USR
Áôº‰ø°Á´ô: Êúà‰∏ãÂ§úÊÉ≥ (2003/12/15 Mon 22:16:09)                Updated: 2004/01/28

  ÈÄôÁØáÊòØÈÖçÂêàÊää.USRÊîæÂÖ•shmÈÇ£ÁØápatchÁöÑ‰øÆÊ≠£„ÄÇ

: maple / acct.c

extern BCACHE *bshm;
+extern SCACHE *schema_shm;


  acct_setup()ÂâçÈù¢ÊäÑ‰∏äÈÄôÊîØ

static void /* amaki.031120: ËôïÁêÜÁ´ôÈï∑ËÆäÊõ¥IDËàáuserno */
schema_rename(old, new)
  ACCT *old, *new;
{
  int scheno;
  SCHEMA u, *p;

  if (old->userno == new->userno) /* Ê≤íËÆäÊõ¥usernoÁöÑËôïÁêÜ */
  {
    scheno = old->userno - 1;
    memset(&u, 0, sizeof(SCHEMA));
    u.uptime = time(0);
    strcpy(u.userid, new->userid);

    rec_put(FN_SCHEMA, &u, sizeof(SCHEMA), scheno, NULL);
    p = schema_shm->schema + scheno;
    memcpy(p, &u, sizeof(SCHEMA));
  }
  else /* ÊúâËÆäÊõ¥usernoÁöÑËôïÁêÜ */
  {
    /* amaki: ÂÖàÊääÊñ∞ÁöÑÂØ´ÈÄ≤Âéª */
    scheno = new->userno - 1;
    memset(&u, 0, sizeof(SCHEMA));
    u.uptime = time(0);
    strcpy(u.userid, new->userid);
    rec_put(FN_SCHEMA, &u, sizeof(SCHEMA), scheno, NULL);
    p = schema_shm->schema + scheno;
    memcpy(p, &u, sizeof(SCHEMA));

    /* ÂÜçÂØ´ËàäÁöÑ */
    scheno = old->userno - 1;
    memset(&u, 0, sizeof(SCHEMA));
    u.uptime = time(0);
    rec_put(FN_SCHEMA, &u, sizeof(SCHEMA), scheno, NULL);
    p = schema_shm->schema + scheno;
    memcpy(p, &u, sizeof(SCHEMA));
  }
}



  Êîπacct_setup()

void
acct_setup(u, adm)
  ACCT *u;
  int adm;
{
  ACCT x;
+ SCHEMA *schema;
[1;32m![m int i, num, [1;32mID_dirty = 0[m;


  ......
  ......

      vget(i, 0, "‰ΩøÁî®ËÄÖ‰ª£Ëôü(‰∏çÊîπË´ãÊåâ Enter)Ôºö", str, IDLEN + 1, GCARRY);
      if (!str_cmp(str, u->userid))
        break;
+     if (!acct_userno(str))
+     {
+       ID_dirty = 1; /* amaki.031120: Êîπ‰∫ÜIDÈÄ£SCHEMA‰πüË¶Å‰∏ÄËµ∑Êîπ */
+       break;
+     }
      vmsg("ÈåØË™§ÔºÅÂ∑≤ÊúâÁõ∏Âêå ID ÁöÑ‰ΩøÁî®ËÄÖ");
    }

  ......
  ......

    vget(++i, 0, "Áî®Êà∂Á∑®ËôüÔºö", buf, 10, GCARRY);
    if ((num = atoi(buf)) > 0)
-     x.userno = num;
+   {
+     schema = schema_shm->schema + (num - 1);
+     if (num == u->userno || !*schema->userid)
+     {
+       x.userno = num;
+       ID_dirty = (num == u->userno) ? ID_dirty : 1;
+     }
+     else
+       zmsg("ÈÄôÂÄãÁ∑®ËôüÂ∑≤Á∂ìÊúâ‰∫∫‰ΩøÁî®ÔºÅ");
+   }

  ......
  ......

  }

+ if (ID_dirty)
+   schema_rename(u, &x);

  memcpy(u, &x, sizeof(x));
  acct_save(u, adm);


: maple / bbsd.c  Êñ∞Ë®ªÂÜäÂ∏≥Ëôü‰πüË¶ÅÂØ´ÂÖ•shm

#define MAXPORTS        1
static int myports[MAXPORTS] = {23 /* , 3456 */};

extern UCACHE *ushm;
+extern SCACHE *schema_shm;

  Êîπacct_apply()

static void
acct_apply()
{
[1;32m![m SCHEMA slot, [1;32m*p[m;
  char buf[80];
  char *userid;
  int try, fd;

  ......
  ......

  fd = open(FN_SCHEMA, O_RDWR | O_CREAT, 0600);
  {
    /* flock(fd, LOCK_EX); */
    /* Thor.981205: Áî® fcntl Âèñ‰ª£flock, POSIXÊ®ôÊ∫ñÁî®Ê≥ï */
    f_exlock(fd);

    cuser.userno = try = uniq_userno(fd);
    write(fd, &slot, sizeof(slot));
+   p = schema_shm->schema + (cuser.userno - 1);
+   memcpy(p, &slot, sizeof(SCHEMA));
    /* flock(fd, LOCK_UN); */
    /* Thor.981205: Áî® fcntl Âèñ‰ª£flock, POSIXÊ®ôÊ∫ñÁî®Ê≥ï */
    f_unlock(fd);
  }
  close(fd);

--
  [1;33mOrigin: luna.twbbs.org[m
