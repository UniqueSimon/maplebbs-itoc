ä½œè€…: itoc (League) çœ‹æ¿: plan
æ¨™é¡Œ: [ä¿®æ­£] å…é€£ç½²çš„çœ‹æ¿ç”³è«‹
æ™‚é–“: 2004/03/16 Tue 23:56:53                           Updated: 2005/05/19

â€» å¼•è¿°ã€Šyenning.bbs@bbs.seehere.org (yenning)ã€‹ä¹‹éŠ˜è¨€ï¼š
> æ˜¯ä¸æ˜¯èƒ½ç”¨æˆåƒitoc.twbbs.orgçš„çœ‹æ¿é€£ç½²ä¸€æ¨£?

  1. æ‹”æŽ‰ newbrd.c çš„æ‰€æœ‰é€£ç½²åŠŸèƒ½ï¼Œ^P åªå‰©ä¸‹ç”³è«‹çœ‹æ¿
  2. å…é€£ç½²çš„çœ‹æ¿ç”³è«‹
  3. å°šæœªé–‹æ¿çš„é¡¯ç¤º '+'ï¼Œå·²é–‹æ¿å®Œç•¢é¡¯ç¤º ' '
     è‹¥æ˜¯ VIP çš„ç”³è«‹ï¼Œåœ¨å°šæœªé–‹æ¿å‰æœƒé¡¯ç¤º '*'
  4. ç”³è«‹çœ‹æ¿æ™‚å³å¡«å…¥æ‰€æœ‰è³‡è¨Šï¼Œç«™é•·æŒ‰ o å°±ç›´æŽ¥é–‹æ¿å®Œæˆ
  5. å¦‚æžœåšäº†ç²¾è¯å€çš„ patchï¼Œé‚£éº¼é‚„ç›´æŽ¥åŠ å…¥ Class
  6. help æ²’æœ‰æ”¹ï¼Œæƒ³å¯«çš„äººå†è‡ªå·±å¯« :p

: theme.h

  NECKER_COSIGNã€FOOTER_COSIGNã€FEETER_COSIGN
  é€™ä¸‰å€‹è‡ªå·±æ”¹ä¸€ä¸‹ï¼Œä¸æ”¹ä¹Ÿæ²’å·®

  æŒ‡ä»¤å°±åªå‰©ä¸‹ (r)è®€å– (^P)ç”³è«‹ (d)åˆªé™¤ (o)é–‹æ¿ (E)ç·¨è¼¯ (^Q/^O)æŸ¥è©¢

: struct.h  HAVE_COSIGN é€™ä¸€æ®µæ”¹æˆé€™æ¨£

#ifdef HAVE_COSIGN

/* ----------------------------------------------------- */
/* newbrd.c ä¸­é‹ç”¨çš„è³‡æ–™çµæ§‹                             */
/* ----------------------------------------------------- */

typedef struct NewBoardHeader
{
  char brdname[BNLEN + 1];
  char class[BCLEN + 1];
  char title[BTLEN + 1];
  time_t btime;
  time_t etime;
  char xname[32];
  char owner[IDLEN + 1];
  char date[9];
  usint mode;
  int readlevel;
}       NBRD;


#define NBRD_FINISH     0x01    /* å·²çµæ¡ˆ */
#define NBRD_VIPAPPLY   0x02    /* VIP çš„ç”³è«‹ */

#endif  /* HAVE_COSIGN */

: newbrd.c æ›æˆä»¥ä¸‹
: ----------------------------------------------------
  æ³¨æ„ is_vip_apply() çš„éƒ¨åˆ†è¦è‡ªå·±æ”¹å¯«ï¼Œç•¶ç„¶ä½ ä¹Ÿå¯ä»¥ç›´æŽ¥ return 0ï¼Œå°±æ²’æœ‰ VIP
       nbrd_add() è£¡é¢çš„åˆ†é¡žä¾å„ç«™è‡ªå®š
  ----------------------------------------------------
  å¦‚æžœé‚„å¸Œæœ›è‡ªå‹•åŠ å…¥ Class åˆ†é¡žï¼Œé‚£éº¼åƒè€ƒç²¾è¯å€é€™ç¯‡
  [åŠŸèƒ½] newbrd.c é€£ç½²é–‹æ¿å¾Œè‡ªå‹•åŠ å…¥ Class
: ----------------------------------------------------

/*-------------------------------------------------------*/
/* newbrd.c   ( YZU_CSE WindTop BBS )                    */
/*-------------------------------------------------------*/
/* target : é€£ç½²åŠŸèƒ½                                     */
/* create : 00/01/02                                     */
/* update : 02/04/29                                     */
/*-------------------------------------------------------*/
/* run/newbrd/_/.DIR - newbrd control header             */
/* run/newbrd/_/@/@_ - newbrd description file           */
/*-------------------------------------------------------*/


#include "bbs.h"


#ifdef HAVE_COSIGN

extern XZ xz[];
extern char xo_pool[];
extern BCACHE *bshm;                /* itoc.010805: é–‹æ–°æ¿ç”¨ */

static int nbrd_add();
static int nbrd_body();
static int nbrd_head();


static int
cmpbtime(nbrd)
  NBRD *nbrd;
{
  return nbrd->btime == currchrono;
}


static int
nbrd_stamp(folder, nbrd, fpath)
  char *folder;
  NBRD *nbrd;
  char *fpath;
{
  char *fname;
  char *family = NULL;
  int rc;
  int token;

  fname = fpath;
  while (rc = *folder++)
  {
    *fname++ = rc;
    if (rc == '/')
      family = fname;
  }

  fname = family;
  *family++ = '@';

  token = time(0);

  archiv32(token, family);

  rc = open(fpath, O_WRONLY | O_CREAT | O_EXCL, 0600);
  nbrd->btime = token;
  str_stamp(nbrd->date, &nbrd->btime);
  strcpy(nbrd->xname, fname);
  return rc;
}


static void
nbrd_fpath(fpath, folder, nbrd)
  char *fpath;
  char *folder;
  NBRD *nbrd;
{
  char *str = NULL;
  int cc;

  while (cc = *folder++)
  {
    *fpath++ = cc;
    if (cc == '/')
      str = fpath;
  }
  strcpy(str, nbrd->xname);
}


static int
nbrd_init(xo)
  XO *xo;
{
  xo_load(xo, sizeof(NBRD));
  return nbrd_head(xo);
}


static int
nbrd_load(xo)
  XO *xo;
{
  xo_load(xo, sizeof(NBRD));
  return nbrd_body(xo);
}


static char
nbrd_attr(nbrd)
  NBRD *nbrd;
{
  /*         å·²é–‹æ¿å®Œæˆç”¨ ' '
     æœªé–‹æ¿çš„ä¸€èˆ¬äººç”³è«‹ç”¨ '+'
     æœªé–‹æ¿çš„ï¼¶ï¼©ï¼°ç”³è«‹ç”¨ '+' (ä¸€èˆ¬ä½¿ç”¨è€…çœ‹åˆ°)
     æœªé–‹æ¿çš„ï¼¶ï¼©ï¼°ç”³è«‹ç”¨ '*' (åªæœ‰ç«™é•·å¯è¦‹)
   */
  usint mode;

  mode = nbrd->mode;
  return mode & NBRD_FINISH ? ' ' :
    (HAS_PERM(PERM_ALLBOARD) && (mode & NBRD_VIPAPPLY) ? '*' : '+');
}


static void
nbrd_item(num, nbrd)
  int num;
  NBRD *nbrd;
{
  prints("%6d %c %-5s %-13s %-13s[%s] %.*s\n",
    num, nbrd_attr(nbrd), nbrd->date + 3, nbrd->owner,
    nbrd->brdname, nbrd->class, d_cols + 29, nbrd->title);
}


static int
nbrd_body(xo)
  XO *xo;
{
  NBRD *nbrd;
  int num, max, tail;

  max = xo->max;
  if (max <= 0)
  {
    if (vans("è¦æ–°å¢žé€£ç½²é …ç›®å—Ž(Y/N)ï¼Ÿ[N] ") == 'y')
      return nbrd_add(xo);
    return XO_QUIT;
  }

  nbrd = (NBRD *) xo_pool;
  num = xo->top;
  tail = num + XO_TALL;

  if (max > tail)
    max = tail;

  move(3, 0);
  do
  {
    nbrd_item(++num, nbrd++);
  } while (num < max);
  clrtobot();

  /* return XO_NONE; */
  return XO_FOOT;        /* itoc.010403: æŠŠ b_lines å¡«ä¸Š feeter */
}


static int
nbrd_head(xo)
  XO *xo;
{
  vs_head("ç”³è«‹çœ‹æ¿", str_site);
  outs(NECKER_COSIGN);
  return nbrd_body(xo);
}


static int
is_vip_apply()                /* æ˜¯ä¸æ˜¯ VIP çš„ç”³è«‹ */
{
  char *str, email[80];

  [1;44m// ä»¥ä¸‹é€™ä¸€æ®µè¦ç”±å„ç«™è‡ªå®š [m
  if (HAS_PERM(PERM_VALID))
  {
    str_lower(email, cuser.email);

    /* æª¢æŸ¥ .ee##(g)@nctu.edu.tw */
    if (str = (char *) strchr(email, '.'))
    {
      if (*(str + 1) == 'e' && *(str + 2) == 'e' &&
        (!strcmp(str + 5, "@nctu.edu.tw") || !strcmp(str + 5, "g@nctu.edu.tw")))
      {
        return 1;
      }
    }

    /* æª¢æŸ¥ u##11###@cc.nctu.edu.tw */
    if (strlen(email) == 23)
    {
      if (email[0] == 'u' && email[3] == '1' && email[4] == '1' &&
        !strcmp(email + 8, "@cc.nctu.edu.tw"))
      {
        return 1;
      }
    }
  }
  [1;44m// ä»¥ä¸Šé€™ä¸€æ®µè¦ç”±å„ç«™è‡ªå®š[m

  return 0;
}


static int
nbrd_add(xo)
  XO *xo;
{
  int fd, readlevel;
  char *dir, fpath[80], path[80], *plevel;
  char *brdname, *title;
  FILE *fp;
  NBRD nbrd;

  if (!cuser.userlevel)
    return XO_NONE;

  memset(&nbrd, 0, sizeof(NBRD));

  brdname = nbrd.brdname;
  title = nbrd.title;

  if (!vget(b_lines, 0, "è‹±æ–‡æ¿åï¼š", brdname, BNLEN + 1, DOECHO))
    return XO_FOOT;

  if (brd_bno(brdname) >= 0)
  {
    vmsg("å·²æœ‰æ­¤æ¿");
    return XO_FOOT;
  }

  if (!valid_brdname(brdname))        /* itoc.020726: æª¢æŸ¥æ¿åæ˜¯å¦åˆæ³• */
  {
    vmsg("æ¿åä¸åˆæ³•");
    return XO_FOOT;
  }

  [1;44m// ä»¥ä¸‹é€™ä¸€æ®µè¦ç”±å„ç«™è‡ªå®š [m
  switch (vans("çœ‹æ¿åˆ†é¡žï¼š1)å€‹äºº 2)å¯¢æ¿ 3)ç­æ¿ 4)é»¨ç¾½ 5)ç‡ŸéšŠ 6)å…¶ä»– [Q] "))
  {
  case '1':
    plevel = "å€‹äºº";
    break;
  case '2':
    plevel = "å¯¢æ¿";
    break;
  case '3':
    plevel = "ç­æ¿";
    break;
  case '4':
    plevel = "é»¨ç¾½";
    break;
  case '5':
    plevel = "ç‡ŸéšŠ";
    break;
  case '6':
    plevel = "ï¼Ÿï¼Ÿ";    /* è®“ç«™é•·è‡ªå·±æ‰‹å‹•æ”¹ */
    vmsg("è«‹æ–¼è£œå……äº‹é …ä¸­è¨»æ˜Žæ‚¨è¦çš„çœ‹æ¿åˆ†é¡ž");
    break;
  default:
    return XO_FOOT;
  }
  [1;44m// ä»¥ä¸Šé€™ä¸€æ®µè¦ç”±å„ç«™è‡ªå®š [m

  strcpy(nbrd.class, plevel);

  readlevel = vans("çœ‹æ¿å±¬æ€§ï¼š1)å…¬é–‹ 2)ç§˜å¯† 3)å¥½å‹ [Q] ") - '0';
  switch (readlevel)
  {
  case 1:
    plevel = "å…¬é–‹";
    break;
  case 2:
    plevel = "ç§˜å¯†";
    break;
  case 3:
    plevel = "å¥½å‹";
    break;
  default:
    return XO_FOOT;
  }

  if (!vget(b_lines, 0, "çœ‹æ¿ä¸»é¡Œï¼š", title, BTLEN + 1, DOECHO))
    return XO_FOOT;

  dir = xo->dir;
  if ((fd = nbrd_stamp(dir, &nbrd, fpath)) < 0)
    return nbrd_head(xo);
  close(fd);

  vmsg("é‚„æœ‰è¦è£œå……ä»€éº¼å—Žï¼Ÿ[ä¾‹å¦‚è½‰ä¿¡ã€è«‚åªšç«™é•·çš„è©±...:p]");
  sprintf(path, "tmp/%s.nbrd", cuser.userid);        /* é€£ç½²åŽŸå› çš„æš«å­˜æª”æ¡ˆ */
  fd = vedit(path, 0);
  if (fd)
  {
    unlink(fpath);
    vmsg(msg_cancel);
    return nbrd_head(xo);
  }

  strcpy(nbrd.owner, cuser.userid);
  nbrd.readlevel = readlevel;
  nbrd.mode = is_vip_apply() ? NBRD_VIPAPPLY : 0;
  rec_add(dir, &nbrd, sizeof(NBRD));

  fp = fopen(fpath, "a+");
  fprintf(fp, "ä½œè€…: %s (%s) ç«™å…§: çœ‹æ¿ç”³è«‹\n", cuser.userid, cuser.username);
  fprintf(fp, "æ¨™é¡Œ: [çœ‹æ¿ç”³è«‹] %s\n", brdname);
  fprintf(fp, "æ™‚é–“: %s\n\n", Now());
  fprintf(fp, "è‹±æ–‡æ¿åï¼š%s\n", brdname);
  fprintf(fp, "çœ‹æ¿åˆ†é¡žï¼š%s\n", nbrd.class);
  fprintf(fp, "çœ‹æ¿ä¸»é¡Œï¼š%s\n", title);
  fprintf(fp, "æ¿ä¸»åç¨±ï¼š%s\n", nbrd.owner);
  fprintf(fp, "çœ‹æ¿å±¬æ€§ï¼š%s\n\n\n", plevel);
  f_suck(fp, path);
  unlink(path);
  fprintf(fp, "\n--\nâ–¡ æœ¬æ–‡ç« ç”± %s å¾ž %s ç”³è«‹\n", cuser.userid, fromhost);
  fclose(fp);

  vmsg("è«‹ç­‰å¾…ç«™é•·é–‹æ¿");
  return nbrd_init(xo);
}


static int                        /* 1:é–‹æ¿æˆåŠŸ */
nbrd_newbrd(nbrd)                /* é–‹æ–°ç‰ˆ */
  NBRD *nbrd;
{
  BRD newboard;
  ACCT acct;

  memset(&newboard, 0, sizeof(BRD));

  /* itoc.010805: æ–°çœ‹æ¿é è¨­ battr = ä¸è½‰ä¿¡; çœ‹æ¿æ¿ä¸»ç‚ºæèµ·é€£ç½²è€… */
  switch (nbrd->readlevel)
  {
  case 2:       /* ç§˜å¯† */
    newboard.readlevel = PERM_SYSOP;
    newboard.battr = BRD_NOTRAN | BRD_NOSTAT | BRD_NOVOTE;
    break;
  case 3:       /* å¥½å‹ */
    newboard.readlevel = PERM_BOARD;
    newboard.battr = BRD_NOTRAN | BRD_NOSTAT | BRD_NOVOTE;
    break;
  default:      /* å…¬é–‹ */
    newboard.postlevel = PERM_POST;
    newboard.battr = BRD_NOTRAN;
    break;
  }
  strcpy(newboard.brdname, nbrd->brdname);
  strcpy(newboard.class, nbrd->class);
  strcpy(newboard.title, nbrd->title);
  strcpy(newboard.BM, nbrd->owner);

  if (acct_load(&acct, nbrd->owner) >= 0)
    acct_setperm(&acct, PERM_BM, 0);

  if (brd_new(&newboard) < 0)
    return 0;

  vmsg("æ–°æ¿æˆç«‹ï¼Œè¨˜è‘—åŠ å…¥åˆ†é¡žç¾¤çµ„");
  return 1;

}


static int
nbrd_open(xo)
  XO *xo;
{
  NBRD *nbrd;

  if (!HAS_PERM(PERM_ALLBOARD))
    return XO_NONE;

  nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);

  /* itoc.030519: é¿å…é‡è¦†é–‹æ¿ */
  if (brd_bno(nbrd->brdname) >= 0)
  {
    nbrd->mode = NBRD_FINISH;
    currchrono = nbrd->btime;
    rec_put(xo->dir, nbrd, sizeof(NBRD), xo->pos, cmpbtime);
    vmsg("å·²æœ‰æ­¤æ¿");
    return nbrd_init(xo);
  }

  if (nbrd->mode & NBRD_FINISH)
  {
    vmsg("å·²å®Œæˆé–‹æ¿");
  }
  else
  {
    if (vans("è«‹ç¢ºå®šé–‹å•Ÿçœ‹æ¿(Y/N)ï¼Ÿ[N] ") == 'y')
    {
      if (nbrd_newbrd(nbrd))
      {
        nbrd->mode = NBRD_FINISH;
        currchrono = nbrd->btime;
        rec_put(xo->dir, nbrd, sizeof(NBRD), xo->pos, cmpbtime);
      }
      return nbrd_init(xo);
    }
  }
  return XO_FOOT;
}


static int
nbrd_browse(xo)
  XO *xo;
{
  int key;
  NBRD *nbrd;
  char fpath[80];

  /* itoc.010304: ç‚ºäº†è®“é–±è®€åˆ°ä¸€åŠä¹Ÿå¯ä»¥åŠ å…¥é€£ç½²ï¼Œè€ƒæ…® more å‚³å›žå€¼ */
  for (;;)
  {
    nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);
    nbrd_fpath(fpath, xo->dir, nbrd);

    if ((key = more(fpath, FOOTER_COSIGN)) < 0)
      break;

    if (!key)
      key = vkey();

    switch (key)
    {
    case KEY_UP:
    case KEY_PGUP:
    case '[':
    case 'k':
      key = xo->pos - 1;

      if (key < 0)
        break;

      xo->pos = key;

      if (key <= xo->top)
      {
        xo->top = (key / XO_TALL) * XO_TALL;
        nbrd_load(xo);
      }
      continue;

    case KEY_DOWN:
    case KEY_PGDN:
    case ']':
    case 'j':
    case ' ':
      key = xo->pos + 1;

      if (key >= xo->max)
        break;

      xo->pos = key;

      if (key >= xo->top + XO_TALL)
      {
        xo->top = (key / XO_TALL) * XO_TALL;
        nbrd_load(xo);
      }
      continue;

    case 'h':
      xo_help("cosign");
      break;
    }
    break;
  }

  return nbrd_head(xo);
}


static int
nbrd_delete(xo)
  XO *xo;
{
  NBRD *nbrd;
  char fpath[80];

  nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);
  if (strcmp(cuser.userid, nbrd->owner) && !HAS_PERM(PERM_ALLBOARD))
    return XO_NONE;

  if (vans(MSG_DEL_NY) != 'y')
    return nbrd_head(xo);

  nbrd_fpath(fpath, xo->dir, nbrd);
  unlink(fpath);

  rec_del(xo->dir, sizeof(NBRD), xo->pos, NULL);
  return nbrd_init(xo);
}


static int
nbrd_edit(xo)
  XO *xo;
{
  if (HAS_PERM(PERM_ALLBOARD))
  {
    char fpath[64];
    NBRD *nbrd;

    nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);
    nbrd_fpath(fpath, xo->dir, nbrd);
    vedit(fpath, 0);
    return nbrd_head(xo);
  }

  return XO_NONE;
}


static int
nbrd_uquery(xo)
  XO *xo;
{
  NBRD *nbrd;

  nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);

  move(1, 0);
  clrtobot();
  my_query(nbrd->owner);
  return nbrd_head(xo);
}


static int
nbrd_usetup(xo)
  XO *xo;
{
  NBRD *nbrd;
  ACCT acct;

  if (!HAS_PERM(PERM_ALLACCT))
    return XO_NONE;

  nbrd = (NBRD *) xo_pool + (xo->pos - xo->top);
  if (acct_load(&acct, nbrd->owner) < 0)
    return XO_NONE;

  move(3, 0);
  acct_setup(&acct, 1);
  return nbrd_head(xo);
}


static int
nbrd_help(xo)
  XO *xo;
{
  xo_help("cosign");
  return nbrd_head(xo);
}


static KeyFunc nbrd_cb[] =
{
  XO_INIT, nbrd_init,
  XO_LOAD, nbrd_load,
  XO_HEAD, nbrd_head,
  XO_BODY, nbrd_body,

  'r', nbrd_browse,
  'd', nbrd_delete,
  'E', nbrd_edit,
  'o', nbrd_open,

  Ctrl('P'), nbrd_add,
  Ctrl('Q'), nbrd_uquery,
  Ctrl('O'), nbrd_usetup,

  'h', nbrd_help
};


int
XoNewBoard()
{
  XO *xo;
  char fpath[64];

  sprintf(fpath, "run/newbrd/%s", fn_dir);
  xz[XZ_COSIGN - XO_ZONE].xo = xo = xo_new(fpath);
  xz[XZ_COSIGN - XO_ZONE].cb = nbrd_cb;
  xo->key = XZ_COSIGN;
  xover(XZ_COSIGN);
  free(xo);

  return 0;
}
#endif        /* HAVE_COSIGN */


--
[1;37mâ–¡ æœ¬æ–‡ç« ç”± [33mitoc[37m å¾ž [32mitoc.Dorm11.NCTU.edu.tw[37m ç™¼è¡¨[m
