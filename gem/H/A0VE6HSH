ç™¼ä¿¡äºº: Iuu.bbs@bupt.cn-bbs.org (éº¥ç±½) çœ‹æ¿: plan
æ¨™  é¡Œ: [åŠŸèƒ½]æ®ºäººéŠæˆ²(è­¦å¯Ÿèˆ‡æ®ºæ‰‹)
ç™¼ä¿¡ç«™: çœŸæƒ…æµéœ² (Wed, 07 May 2003 13:20:23 +0800 (CST))  Updated: 2004/10/30

    ä¸çŸ¥é“å¤§å®¶æ˜¯å¦ç©éè­¦å¯Ÿèˆ‡æ®ºæ‰‹çš„éŠæˆ²ï¼Œå¤§æ¦‚èªªèµ·ä¾†ï¼Œ
æ˜¯ä¸€å€‹å¤šäººçš„é¬¥æ™ºéŠæˆ²ã€‚å¯ä»¥é€šéä½¿ç”¨bbsçš„èŠå¤©å®¤ä¾†å®Œæˆï¼Œ
ç•¶ç„¶ï¼Œå¤šå€‹äººèšåœ¨ä¸€èµ·ç¾å ´éŠæˆ²ä¹Ÿå¾ˆæœ‰æ°£æ°›ã€‚

    ä¸‹é¢æ˜¯éœ€è¦æ”¹å‹•çš„ä»£ç¢¼ï¼Œå¥½åœ¨æ”¹å‹•çš„æ–‡ä»¶å¹¶ä¸å¤šï¼Œå¹¶ä¸”
æ‰€æœ‰ä»£ç¢¼éƒ½æ˜¯åœ¨ #ifdef HAVE_KILL_GAME #endif ä¸­çš„ã€‚å
é¢æœƒç²˜è²¼ç›¸é—œçš„éŠæˆ²è¦å‰‡ã€‚éœ€æ”¹å‹•çš„æ–‡ä»¶æœ‰ï¼š
config.h  chatd.c xchatd.c
    coded by esp @ çœŸæƒ…æµéœ²

: config.h

#define LOG_TALK                /* lkchu.981201: èŠå¤©è¨˜éŒ„è™•ç† */

+ #define HAVE_KILL_GAME        /* esp.030414: æ˜¯å¦æä¾›æ®ºæ‰‹éŠæˆ² */

: chat.c:chat_recv()

      else if (fd == 't')
      {
        str_ncpy(chatopic, str, sizeof(chatopic));
        chat_topic();
      }
#ifdef HAVE_KILL_GAME
      else if (fd == 'k') /* esp: only send /k on entering a kill-game room */
      {
        char temp[10];

        for (fd = 2; fd < stop_line; fd++)
        {
          move(fd,0);
          clrtoeol();
        }
        sscanf(str, "%s", temp);
        chatline = atoi(temp);
        move(chatline, 0);
      }
      else if (fd == 'u')    /* esp: refresh the top user table */
      {
        char temp[10];

        sscanf(str, "%s", temp);
        fd = atoi(temp);
        str = strchr(str, ' ') + 1;
        cursor_save();
        move(fd, 0);
        outs(str);
        cursor_restore();
      }
#endif

: xchatd.c

  åœ¨ maple/xchatd.c ä¸­å¢åŠ çš„ä»£ç¢¼æ•¸é‡æ¯”è¼ƒå¤šï¼Œä¹Ÿæ˜¯å…¨éƒ¨
å®šç¾©åœ¨ #define HAVE_KILL_GAME #endif ä¸­çš„ã€‚
  å° xchatd.c ä¸­å¢åŠ çš„ä»£ç¢¼æœ‰28è™•ï¼Œä¸€ä¸€åˆ—å‡ºä¾†ï¼Œè«‹æœç´¢
#define HAVE_KILL_GAMEï¼ŒæŠŠé€™éƒ¨åˆ†çš„ä»£ç¢¼åŠ åˆ°è‡ªå·±çš„ xchatd.c ä¸­ã€‚
  æ³¨æ„ï¼Œå¦‚æœç›´æ¥ä¸‹è¼‰çš„è©±ï¼Œæœ‰äº›ä»£ç¢¼å› ç‚ºè¶…éäº†80å­—ï¼Œæ‰€
ä»¥bbsè‡ªå‹•åšäº†å›è¡Œï¼Œé€™éƒ¨åˆ†ä½¿ç”¨çš„æ™‚å€™ï¼Œè¦ä¿®æ­£ã€‚

/*-------------------------------------------------------*/
/* xchatd.c     ( NTHU CS MapleBBS Ver 3.00 )            */
/*-------------------------------------------------------*/
/* target : super KTV daemon for chat server             */
/* create : 95/03/29                                     */
/* update : 97/10/20                                     */
/*-------------------------------------------------------*/


#include "bbs.h"
#include "xchat.h"


#ifdef HAVE_KILL_GAME
typedef struct
{
  int won;
  int lost;
  int dropped;
  int nreserved;
  int lastgame;   /* win or lose or drop */
  time_t tlastgame;
  time_t treserved;
} KILL_STATE;
#endif



#include <stdlib.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <fcntl.h>

#if defined(AIX) || defined(HIGHGCC)
#include <sys/time.h>
#else
#include <time.h>
#endif          /* hightman.011028: Redhat7.xæœ‰é»æ€ª :) */

#include <sys/resource.h>


#ifdef SOLARIS
extern char *sys_errlist[];
#endif


#define SERVER_USAGE
#define WATCH_DOG
#undef  DEBUG           /* ç¨‹å¼é™¤éŒ¯ä¹‹ç”¨ */
#undef  MONITOR         /* ç›£ç£ chatroom æ´»å‹•ä»¥è§£æ±ºç³¾ç´› */
#undef  STAND_ALONE     /* ä¸æ­é… BBS ç¨ç«‹åŸ·è¡Œ */


#ifdef  DEBUG
#define MONITOR
#endif

static int gline;

#ifdef  WATCH_DOG
#define MYDOG  gline = __LINE__
#else
#define MYDOG           /* NOOP */
#endif


#define CHAT_PIDFILE    "run/chat.pid"
#define CHAT_LOGFILE    "run/chat.log"
#define CHAT_INTERVAL   (60 * 30)
#define SOCK_QLEN   3


/* name of the main room (always exists) */


#define MAIN_NAME   "main"
#define MAIN_TOPIC  "èæ°´ç›¸é€¢è‡ªæœ‰ç·£"


#define ROOM_LOCKED 0x01
#define ROOM_SECRET 0x02
#define ROOM_OPENTOPIC  0x04
/* fuse.991210: æ²’æœ‰å‹•ä½œï¼Œæ²’æœ‰ç³»çµ±è¨Šæ¯çš„èŠå¤©å®¤ */
#define ROOM_QUIET  0x08
#define ROOM_INTERVIEW  0x10

/* esp.030414: æ®ºäººéŠæˆ² */
#ifdef HAVE_KILL_GAME
#define ROOM_KILLGAME   0x20
#define ROOM_KILL_STARTED 0x40
#define ROOM_KILL_WAITDROP 0x80
#define ROOM_KILL_DISCUSS 0x100
#define ROOM_KILL_NOGHOST 0x200
#define ROOM_KILL_POLICE 0x400
#define ROOM_KILL_NOPOLICE 0x800
#define ROOM_KILL_STRPOLICE 0x1000
#endif


#define ROOM_ALL    (NULL)


#define LOCKED(room)    (room->rflag & ROOM_LOCKED)
#define SECRET(room)    (room->rflag & ROOM_SECRET)
#define OPENTOPIC(room) (room->rflag & ROOM_OPENTOPIC)
#define QUIET(room) (room->rflag & ROOM_QUIET)
#define INTERVIEW(room) (room->rflag & ROOM_INTERVIEW)


#define RESTRICTED(usr) (usr->uflag == 0)   /* guest */
#define CHATSYSOP(usr)  (usr->uflag & (PERM_SYSOP | PERM_CHATROOM))
#define PERM_ROOMOP PERM_CHAT   /* Thor: å€Ÿ PERM_CHATç‚º PERM_ROOMOP */
#define PERM_CHATOP PERM_DENYCHAT   /* Thor: å€Ÿ PERM_DENYCHATç‚º PERM_CHATOP */
/* #define ROOMOP(usr)  (usr->uflag & ( PERM_ROOMOP | PERM_SYSOP | PERM_CHATROO
M)) */
/* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— chatop*/
#define ROOMOP(usr)  (usr->uflag & (PERM_ROOMOP|PERM_CHATOP))
#define CLOAK(usr)  (usr->uflag & PERM_CLOAK)

#ifdef HAVE_KILL_GAME

#define KILL_ROLE_MASK 0x0F

#define KILL_NONE 0
#define KILL_JUDGE 1
#define KILL_POLICE 2
#define KILL_KILLER 3
#define KILL_NORMAL 4

#define KILL_ROLE(x) (x->killflag & KILL_ROLE_MASK)

#define KILL_KILLED 0x10
#define KILL_KNOCKOUT 0x20
#define KILL_VOTED 0x40
#define KILL_TALKED 0x80 // esp: use it for talk & look around
#define KILL_DROPED 0x100 // esp: for reconnect...
#define KILL_QUERYED 0x200 // esp: police use this for done,killer use this for
 having been queryed

/* kill game status */

#define KILL_NOT_START 0
#define KILL_NIGHT_KILLER 1
#define KILL_NIGHT_POLICE 2
#define KILL_DAY_MURDERED 3
#define KILL_DAY_TALK 4
#define KILL_DAY_VOTE 5
#define KILL_AFTERDAY 6
#define KILL_BEFORENIGHT 7

/* kill user states */
#define KILL_USER_UNKNOWN 0
#define KILL_USER_KILLER 1
#define KILL_USER_KILLED_KILLER 2
#define KILL_USER_POLICE 3
#define KILL_USER_KILLED_POLICE 4
#define KILL_USER_MISKILLED_POLICE 5
#define KILL_USER_NORMAL 6
#define KILL_USER_KILLED_NORMAL 7
#define KILL_USER_MISKILLED_NORMAL 8
#define KILL_USER_JUDGE 9
#define KILL_USER_JUSTKILLED 10

/* states only for the judge */
#define KILL_JUDGE_FRESH 0
#define KILL_JUDGE_KILLED 1 /* esp: prevent judge from kill more at one round o
r no kill at all */

static char userkillstates[11][11] =
{
  "ç›®å‰æœªçŸ¥",
  "æ®ºæ‰‹",
  "è¢«æ®ºæ®ºæ‰‹",
  "è­¦å¯Ÿ",
  "è¢«æ®ºè­¦å¯Ÿ",
  "è¢«å†¤æ®ºè­¦å¯Ÿ",
  "å¹³æ°‘",
  "è¢«æ®ºå¹³æ°‘",
  "è¢«å†¤æ®ºå¹³æ°‘",
  "æ³•å®˜",
  "è¢«æ®º"
};

static char userkillstatecolors[11][10] = {
  "\033[37m",
  "\033[1;31m",
  "\033[4;31m",
  "\033[1;32m",
  "\033[4;32m",
  "\033[1;4;32m",
  "\033[1;33m",
  "\033[4;33m",
  "\033[1;4;33m",
  "\033[30;47m",
  "\033[4m"
};
#endif

/* ----------------------------------------------------- */
/* ChatRoom data structure                               */
/* ----------------------------------------------------- */


typedef struct ChatRoom ChatRoom;
typedef struct ChatUser ChatUser;
typedef struct UserList UserList;
typedef struct ChatCmd ChatCmd;
typedef struct ChatAction ChatAction;


struct ChatUser
{
  ChatUser *unext;
  ChatRoom *room;
  UserList *ignore;
  int sock;         /* user socket */
  int userno;
  int uflag;
  int clitype;          /* Xshadow: client type. 1 for common client,
                 * 0 for bbs only client */
#ifdef HAVE_KILL_GAME
  int killflag;
  int killstate;
  int votenum;
  char killid[16];
  time_t tkillbegin;
#endif

  time_t tbegin;
  time_t uptime;
  int sno;
  int xdata;
  int retry;

  int isize;            /* current size of ibuf */
  char ibuf[80];        /* buffer for non-blocking receiving */
  char userid[IDLEN + 1];   /* real userid */
  char chatid[9];       /* chat id */
  char rhost[30];       /* host address */
};


struct ChatRoom
{
  ChatRoom *next, *prev;
  UserList *invite;
  char name[IDLEN];
  char topic[48];       /* Let the room op to define room topic */
  int rflag;            /* ROOM_LOCKED, ROOM_SECRET, ROOM_OPENTOPIC */
#ifdef HAVE_KILL_GAME
  int killstatus;
  /* esp: the judge always only one */
  int policenum;
  int killernum;
  int normalnum;
  ChatUser *currenttalker;
  time_t tvotebegin;
#endif
  int occupants;        /* number of users in room */
};


struct UserList
{
  UserList *next;
  int userno;
  char userid[0];
};


struct ChatCmd
{
  char *cmdstr;
  void (*cmdfunc) ();
  int exact;
};


static ChatRoom mainroom, *roompool;
static ChatUser *mainuser, *userpool;
static fd_set mainfset;
static int totaluser;       /* current number of connections */
static struct timeval zerotv;   /* timeval for selecting */
static int common_client_command;

/* fuse.991211:è¢«é‡‡è¨ªäºº */
static char interviewer[20];

#ifdef STAND_ALONE
static int userno_inc = 0;  /* userno auto-incrementer */
#endif


static char msg_not_op[] = "â—† æ‚¨ä¸æ˜¯é€™é–“èŠå¤©å®¤çš„ Op";
static char msg_no_such_id[] = "â—† ç›®å‰æ²’æœ‰äººä½¿ç”¨ [%s] é€™å€‹èŠå¤©ä»£è™Ÿ";
static char msg_not_here[] = "â—† [%s] ä¸åœ¨é€™é–“èŠå¤©å®¤";


#define FUZZY_USER  ((ChatUser *) -1)


#ifdef HAVE_KILL_GAME

/* esp: kill game functions */

static void kill_start(ChatUser* cu, char* msg);
static void kill_end(ChatUser* cu, char* msg);
static void kill_parse_start_options(ChatRoom *room, char* msg);
// static void kill_sunrise(ChatUser *cu, char* msg);
// static void kill_sunset(ChatUser *cu, char* msg);
// static void kill_vote(ChatUser *cu, char* msg);
// static void kill_user_vote(ChatUser *cu, char* msg);
// static void kill_clear_vote(ChatUser *cu, char* msg);
static void kill_kill(ChatUser *cu, char* msg);
static int kill_can_talk_between(ChatRoom *room, ChatUser *cu, ChatUser *xuser)
;
static int kill_can_talk(ChatRoom *room, ChatUser *user );
static int kill_get_user_state(ChatRoom *room, ChatUser *cu, ChatUser *user);
static void kill_refresh_table(ChatRoom* room);
static void kill_over(ChatUser *cu, char *msg);
// static void kill_killer_over(ChatRoom *room, ChatUser *cu);
// static void kill_police_over(ChatRoom *room, ChatUser *cu);
static void kill_talk_over(ChatRoom *room, ChatUser *cu);
static int kill_on_user_over(ChatRoom *room);
static ChatUser *kill_get_next_user(ChatRoom *room, ChatUser *cu);
static void kill_check_vote(ChatRoom* room, ChatUser* cu);
static void kill_clear_user_state(ChatRoom* room);
static void kill_on_reconnect(ChatRoom* room);
static void kill_police_query(ChatUser *cu, char* msg);
static void kill_show_next_killer(ChatRoom *room);
static void kill_talk_time_check(ChatRoom *room);
static void kill_vote_time_check(ChatRoom *room);
static ChatUser* kill_auto_vote(ChatRoom *room);
static void kill_kkk(ChatUser *user,char* msg);
static void kill_log_state(ChatUser *user, int nMode);
static void kill_show_state(ChatUser *cu, char *msg);

#endif

/* ----------------------------------------------------- */
/* operation log and debug information                   */
/* ----------------------------------------------------- */


static FILE *flog;


/* Thor.990211: çµ±ä¸€ç”¨ dao library */
#define str_time(t) Btime(t)

#if 0
static char *
str_time(t)
  time_t *t;
{
  static char buf[20];
  struct tm *p;

  p = localtime(t);
  sprintf(buf, "%02d/%02d %02d:%02d:%02d",
    p->tm_mon + 1, p->tm_mday,
    p->tm_hour, p->tm_min, p->tm_sec);
  return buf;
}

#endif

static void
logit(key, msg)
  char *key;
  char *msg;
{
  time_t now;
  struct tm *p;

  time(&now);
  p = localtime(&now);
  fprintf(flog, "%02d/%02d %02d:%02d:%02d %-13s%s\n",
    p->tm_mon + 1, p->tm_mday,
    p->tm_hour, p->tm_min, p->tm_sec, key, msg);
}


static inline void
log_init()
{
  FILE *fp;

  /* --------------------------------------------------- */
  /* log daemon's PID                    */
  /* --------------------------------------------------- */

  if (fp = fopen(CHAT_PIDFILE, "w"))
  {
    fprintf(fp, "%d\n", getpid());
    fclose(fp);
  }

  flog = fopen(CHAT_LOGFILE, "a");
  logit("START", "chat daemon");
}


#ifdef  DEBUG
static char chatbuf[256];   /* general purpose buffer */


static void
debug_list(list)
  UserList *list;
{
  char buf[80];
  int i = 0;

  if (!list)
  {
    logit("DEBUG_L", "NULL");
    return;
  }
  while (list)
  {
    sprintf(buf, "%d) list: %p userno: %d next: %p", i++, list, list->userno, l
ist->next);
    logit("DEBUG_L", buf);

    list = list->next;
  }
  logit("DEBUG_L", "end");
}


static void
debug_user()
{
  ChatUser *user;
  int i;
  char buf[80];

  sprintf(buf, "mainuser: %p userpool: %p", mainuser, userpool);
  logit("DEBUG_U", buf);
  for (i = 0, user = mainuser; user; user = user->unext)
  {
    /* MYDOG; */
    sprintf(buf, "%d) %p %-6d %s %s", ++i, user, user->userno, user->userid, us
er->chatid);
    logit("DEBUG_U", buf);
  }
}


static void
debug_room()
{
  ChatRoom *room;
  int i;
  char buf[80];

  i = 0;
  room = &mainroom;

  sprintf(buf, "mainroom: %p roompool: %p", mainroom, roompool);
  logit("DEBUG_R", buf);
  do
  {
    MYDOG;
    sprintf(buf, "%d) %p %s %d", ++i, room, room->name, room->occupants);
    logit("DEBUG_R", buf);
  } while (room = room->next);
}


static void
log_user(cu)
  ChatUser *cu;
{
  static int log_num;

  if (cu)
  {
    if (log_num > 100 && log_num < 150)
    {
      sprintf(chatbuf, "%d: %p <%d>", log_num, cu, gline);
      logit("travese user ", chatbuf);
    }
    else if (log_num == 100)
    {
      sprintf(chatbuf, "BOOM !! at line %d", gline);
      logit("travese user ", chatbuf);
    }
    log_num++;
  }
  else
    log_num = 0;
}
#endif              /* DEBUG */


/* ----------------------------------------------------- */
/* string routines                                       */
/* ----------------------------------------------------- */


static int
valid_chatid(id)
  char *id;
{
  int ch, len;

  for (len = 0; ch = *id; id++)
  { /* Thor.980921: ç©ºç™½ç‚ºä¸åˆç†chatid, æ€•getnextåˆ¤æ–·éŒ¯èª¤ç­‰ç­‰ */
    if (ch == '/' || ch == '*' || ch == ':' || ch ==' ')
      return 0;
    if (++len > 8)
      return 0;
  }
  return len;
}


#if 0
static void
str_lower(dst, src)
  char *dst, *src;
{
  int ch;

  do
  {
    ch = *src++;
    if (ch >= 'A' && ch <= 'Z')
      ch += 0x20;
    *dst++ = ch;
  } while (ch);
}


static void
str_ncpy(dst, src, n)
  char *dst;
  char *src;
  int n;
{
  char *end;

  end = dst + n;

  do
  {
    n = (dst == end) ? 0 : *src++;
    *dst++ = n;
  } while (n);
}
#endif


/* Case Independent strcmp : 1 ==> euqal */


/* Thor.990211: çµ±ä¸€ä½¿ç”¨dao library */
#define str_equal(s1,s2) (!str_cmp(s1,s2))
#if 0
static int
str_equal(s1, s2)
  uschar *s1;       /* lower-case (sub)string */
  uschar *s2;
{
  int c1, c2;

  for (;;)
  {
    c1 = *s1;

    c2 = *s2;
    if (c2 >= 'A' && c2 <= 'Z')
      c2 += 32;

    if (c1 != c2)
      return 0;

    if (!c1)
      return 1;

    s1++;
    s2++;
  }
}

#endif

/* ----------------------------------------------------- */
/* match strings' similarity case-insensitively          */
/* ----------------------------------------------------- */
/* str_match(keyword, string)                */
/* ----------------------------------------------------- */
/* 0 : equal            ("foo", "foo")                   */
/* -1 : mismatch        ("abc", "xyz")                   */
/* ow : similar         ("goo", "good")                  */
/* ----------------------------------------------------- */


static int
str_match(s1, s2)
  uschar *s1;       /* lower-case (sub)string */
  uschar *s2;
{
  int c1, c2;

  for (;;)
  {
    c1 = *s1;
    c2 = *s2;

    if (!c1)
      return c2;

    if (c2 >= 'A' && c2 <= 'Z')
      c2 += 32;

    if (c1 != c2)
      return -1;

    s1++;
    s2++;
  }
}


/* ----------------------------------------------------- */
/* search user/room by its ID                            */
/* ----------------------------------------------------- */


static ChatUser *
cuser_by_userid(userid)
  char *userid;
{
  ChatUser *cu;
  char buf[80]; /* Thor.980727: ä¸€æ¬¡æœ€é•·æ‰80 */

  str_lower(buf, userid);
  for (cu = mainuser; cu; cu = cu->unext)
  {
    if (!cu->userno)
      continue;
    if (str_equal(buf, cu->userid))
      break;
  }
  return cu;
}


static ChatUser *
cuser_by_chatid(chatid)
  char *chatid;
{
  ChatUser *cu;
  char buf[80]; /* Thor.980727: ä¸€æ¬¡æœ€é•·æ‰80 */

  str_lower(buf, chatid);

  for (cu = mainuser; cu; cu = cu->unext)
  {
    if (!cu->userno)
      continue;
    if (str_equal(buf, cu->chatid))
      break;
  }
  return cu;
}


static ChatUser *
fuzzy_cuser_by_chatid(chatid)
  char *chatid;
{
  ChatUser *cu, *xuser;
  int mode;
  char buf[80]; /* Thor.980727: ä¸€æ¬¡æœ€é•·æ‰80 */

  str_lower(buf, chatid);
  xuser = NULL;

  for (cu = mainuser; cu; cu = cu->unext)
  {
    if (!cu->userno)
      continue;

    mode = str_match(buf, cu->chatid);
    if (mode == 0)
      return cu;

    if (mode > 0)
    {
      if (xuser)
    return FUZZY_USER;  /* ç¬¦åˆè€…å¤§æ–¼ 2 äºº */

      xuser = cu;
    }
  }
  return xuser;
}


static ChatRoom *
croom_by_roomid(roomid)
  char *roomid;
{
  ChatRoom *room;
  char buf[80]; /* Thor.980727: ä¸€æ¬¡æœ€é•·æ‰80 */

  str_lower(buf, roomid);
  room = &mainroom;
  do
  {
    if (str_equal(buf, room->name))
      break;
  } while (room = room->next);
  return room;
}


/* ----------------------------------------------------- */
/* UserList routines                                     */
/* ----------------------------------------------------- */


static void
list_free(list)
  UserList **list;
{
  UserList *user, *next;

  for (user = *list, *list = NULL; user; user = next)
  {
    next = user->next;
    free(user);
  }
}


static void
list_add(list, user)
  UserList **list;
  ChatUser *user;
{
  UserList *node;
  char *userid;
  int len;

  len = strlen(userid = user->userid) + 1;
  if (node = (UserList *) malloc(sizeof(UserList) + len))
  {
    node->next = *list;
    node->userno = user->userno;
    memcpy(node->userid, userid, len);
    *list = node;
  }
}


static int
list_delete(list, userid)
  UserList **list;
  char *userid;
{
  UserList *node;
  char buf[80]; /* Thor.980727: è¼¸å…¥ä¸€æ¬¡æœ€é•·æ‰ 80 */

  str_lower(buf, userid);

  while (node = *list)
  {
    if (str_equal(buf, node->userid))
    {
      *list = node->next;
      free(node);
      return 1;
    }
    list = &node->next;
  }

  return 0;
}


static int
list_belong(list, userno)
  UserList *list;
  int userno;
{
  while (list)
  {
    if (userno == list->userno)
      return 1;
    list = list->next;
  }
  return 0;
}


/* ------------------------------------------------------ */
/* non-blocking socket routines : send message to users   */
/* ------------------------------------------------------ */


static void
do_send(nfds, wset, msg)
  int nfds;
  fd_set *wset;
  char *msg;
{
  int len, sr;

#if 1
  /* Thor: for future reservation bug */
  zerotv.tv_sec = 0;
  zerotv.tv_usec = 0;
#endif

  sr = select(nfds + 1, NULL, wset, NULL, &zerotv);

  if (sr > 0)
  {
    len = strlen(msg) + 1;
    do
    {
      if (FD_ISSET(nfds, wset))
      {
    send(nfds, msg, len, 0);
    if (--sr <= 0)
      return;
      }
    } while (--nfds > 0);
  }
}


static void
send_to_room(room, msg, userno, number, fromuser)
  ChatRoom *room;
  char *msg;
  int userno;
  int number;
  ChatUser *fromuser;
{
  ChatUser *cu;
  fd_set wset;
  int sock, max;
  int clitype;          /* åˆ†ç‚º bbs client åŠ common client å…©æ¬¡è™•ç† */
  char *str, buf[256];

  for (clitype = (number == MSG_MESSAGE || !number) ? 0 : 1;
    clitype < 2; clitype++)
  {
    FD_ZERO(&wset);
    max = -1;

    for (cu = mainuser; cu; cu = cu->unext)
    {
      if (cu->userno && (cu->clitype == clitype) &&
    (room == ROOM_ALL || room == cu->room) &&
    (!userno || !list_belong(cu->ignore, userno)))
      {
#ifdef HAVE_KILL_GAME
        if(fromuser != NULL)
        {
          if(!kill_can_talk_between(room, fromuser,cu))
            continue;
        }
#endif
    sock = cu->sock;

    FD_SET(sock, &wset);

    if (max < sock)
      max = sock;
      }
    }

    if (max <= 0)
      continue;

    if (clitype)
    {
      str = buf;

      if (*msg)
    sprintf(str, "%3d %s", number, msg);
      else
    sprintf(str, "%3d", number);
    }
    else
    {
      str = msg;
    }

    do_send(max, &wset, str);
  }
}


static void
send_to_user(user, msg, userno, number)
  ChatUser *user;
  char *msg;
  int userno;
  int number;
{
  int sock;

#if 0
  if (!user->userno || (!user->clitype && number && number != MSG_MESSAGE))
#endif
  /* Thor.980911: å¦‚æœæŸ¥user->usernoå‰‡åœ¨login_userçš„error messageæœƒç„¡æ³•é€å› */
  if (!user->clitype && number != MSG_MESSAGE)
    return;


  if ((sock = user->sock) <= 0)
    return;

  if (!userno || !list_belong(user->ignore, userno))
  {
    fd_set wset;
    char buf[256];

    FD_ZERO(&wset);
    FD_SET(sock, &wset);

    if (user->clitype)
    {
      if (*msg)
    sprintf(buf, "%3d %s", number, msg);
      else
    sprintf(buf, "%3d", number);
      msg = buf;
    }

    do_send(sock, &wset, msg);
  }
}


/* ----------------------------------------------------- */


static void
room_changed(room)
  ChatRoom *room;
{
  if (room)
  {
    char buf[256];

    sprintf(buf, "= %s %d %d %s",
      room->name, room->occupants, room->rflag, room->topic);
    send_to_room(ROOM_ALL, buf, 0, MSG_ROOMNOTIFY,NULL);
  }
}


static void
user_changed(cu)
  ChatUser *cu;
{
  if (cu)
  {
    ChatRoom *room;
    char buf[256];

    room = cu->room;
    sprintf(buf, "= %s %s %s %s%s",
      cu->userid, cu->chatid, room->name, cu->rhost,
      ROOMOP(cu) ? " Op" : "");
    send_to_room(room, buf, 0, MSG_USERNOTIFY,NULL);
  }
}


static void
exit_room(user, mode, msg)
  ChatUser *user;
  int mode;
  char *msg;
{
  ChatRoom *room;
  usint uflag;
  char buf[128];

  if (!(room = user->room))
    return;

  uflag = user->uflag;
  user->room = NULL;
  /* user->uflag &= ~(PERM_ROOMOP | PERM_SYSOP | PERM_CHATROOM); */
  user->uflag &= ~PERM_ROOMOP;
  /* Thor.980601: é›¢é–‹æˆ¿é–“æ™‚åªæ¸… room op, ä¸æ¸… sysop,chatroom,å› å¤©ç”Ÿå…·æœ‰ */

  if (--room->occupants > 0)
  {
    char *chatid;

    chatid = user->chatid;
    switch (mode)
    {
    case EXIT_LOGOUT:

      sprintf(buf, "â—† %s é›¢é–‹äº† ...", chatid);
      if (msg && *msg)
      {
    strcat(buf, ": ");

#if 1
    msg[79] = 0;        /* Thor:é˜²æ­¢å¤ªé•· */
#endif

    strncat(buf, msg, 79);
      }
      break;

    case EXIT_LOSTCONN:

      sprintf(buf, "â—† %s æˆäº†æ–·ç·šçš„é¢¨ç®å›‰", chatid);
      break;

    case EXIT_KICK:

      sprintf(buf, "â—† å“ˆå“ˆï¼%s è¢«è¸¢å‡ºå»äº†", chatid);
      break;
    }

    /* fuse.991210: QUIETæ¨¡å¼ä¸‹ä¸é¡¯ç¤ºé›¢é–‹è¨Šæ¯ */
    if ((!CLOAK(user)) && (!INTERVIEW(room)))
      send_to_room(room, buf, 0, MSG_MESSAGE,NULL);

    sprintf(buf, "- %s", user->userid);
    send_to_room(room, buf, 0, MSG_USERNOTIFY,NULL);
    room_changed(room);
#ifdef HAVE_KILL_GAME
    if(room->rflag & ROOM_KILL_STARTED)
    {
      if (mode == EXIT_LOSTCONN || mode == EXIT_LOGOUT)
        kill_log_state(user, 3); // 3 for DROP

      send_to_room(room,"\033[1;31må”‰ï¼Œæ²’è¾¦æ³•ï¼Œé‡æ–°é–‹å§‹å§ã€‚\033[m", 0, MSG_MESSAGE, NULL);
      send_to_room(room,"\033[1;33m$$         é€™ä¸€è¼ªçš„éŠæˆ²è¢«æå‰çµæŸäº†\033[m", 0, MSG_MESSAGE, NULL);

      room->rflag &= ~ROOM_KILL_STARTED;
      room->killstatus = KILL_NOT_START;
      kill_refresh_table(room);

      kill_clear_user_state(room);
    }
#endif
  }
  else if (room != &mainroom)
  {
    ChatRoom *next;

    fprintf(flog, "room-\t[%d] %s\n", user->sno, room->name);
    sprintf(buf, "- %s", room->name);

    room->prev->next = next = room->next;
    if (next)
      next->prev = room->prev;

    list_free(&room->invite);

    /* free(room); */

    /* å›æ”¶ */
    room->next = roompool;
    roompool = room;

    send_to_room(ROOM_ALL, buf, 0, MSG_ROOMNOTIFY,NULL);
  }
}


/* ----------------------------------------------------- */
/* chat commands                                         */
/* ----------------------------------------------------- */


#ifndef STAND_ALONE
/* ----------------------------------------------------- */
/* BBS server side routines                              */
/* ----------------------------------------------------- */


/* static */
int
acct_load(acct, userid)
  ACCT *acct;
  char *userid;
{
  int fd;

  usr_fpath((char *) acct, userid, FN_ACCT);
  fd = open((char *) acct, O_RDONLY);
  if (fd >= 0)
  {
    read(fd, acct, sizeof(ACCT));
    close(fd);
  }
  return fd;
}


static void
chat_query(cu, msg)
  ChatUser *cu;
  char *msg;
{
  FILE *fp;
  ACCT acct;
  char buf[256];

  /* Thor.980617: å¯å…ˆæŸ¥æ˜¯å¦ç‚ºç©ºå­—ä¸² */
  if (*msg && acct_load(&acct, msg) >= 0)
  {
    sprintf(buf, "%s(%s) å…±ä¸Šç«™ %d æ¬¡ï¼Œæ–‡ç«  %d ç¯‡",
      acct.userid, acct.username, acct.numlogins, acct.numposts);
    send_to_user(cu, buf, 0, MSG_MESSAGE);

    sprintf(buf, "æœ€è¿‘(%s)å¾(%s)ä¸Šç«™", Btime(&acct.lastlogin),
      (acct.lasthost[0] ? acct.lasthost : "å¤–å¤ªç©º"));
    send_to_user(cu, buf, 0, MSG_MESSAGE);

    usr_fpath(buf, acct.userid, "plans");
    if (fp = fopen(buf, "r"))
    {
      int i;

      i = 0;
      while (fgets(buf, 255, fp) && buf[0])
      {
    buf[strlen(buf) - 1] = 0;
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    if (++i >= MAXQUERYLINES)
      break;
      }
      fclose(fp);
    }
  }
  else
  {
    sprintf(buf, msg_no_such_id, msg);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }
}
#endif


static void
chat_clear(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (cu->clitype)
    send_to_user(cu, "", 0, MSG_CLRSCR);
  else
    send_to_user(cu, "/c", 0, MSG_MESSAGE);
}


static void
chat_date(cu, msg)
  ChatUser *cu;
  char *msg;
{
  time_t thetime;
  char buf[128];

  time(&thetime);
  sprintf(buf, "â—† æ¨™æº–æ™‚é–“: %s", Btime(&thetime));
  send_to_user(cu, buf, 0, MSG_MESSAGE);
}


static void
chat_topic(cu, msg)
  ChatUser *cu;
  char *msg;
{
  ChatRoom *room;
  char *topic, buf[128];

  room = cu->room;

  if (!ROOMOP(cu) && !OPENTOPIC(room))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  if (*msg == '\0')
  {
    send_to_user(cu, "â€» è«‹æŒ‡å®šè©±é¡Œ", 0, MSG_MESSAGE);
    return;
  }

  topic = room->topic;
  /* str_ncpy(topic, msg, sizeof(room->topic) - 1); */
  str_ncpy(topic, msg, sizeof(room->topic));
  /* Thor.980921: str_ncpy å·²å« 0ä¹‹ç©ºé–“ */
#ifdef HAVE_KILL_GAME
  if (room->rflag & ROOM_KILLGAME)
    strcat(topic, "K");
#endif

  if (cu->clitype)
  {
    send_to_room(room, topic, 0, MSG_TOPIC,NULL);
  }
  else
  {
    sprintf(buf, "/t%s", topic);
    send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  }

  room_changed(room);

  if (!CLOAK(cu))
  {
    sprintf(buf, "â—† %s å°‡è©±é¡Œæ”¹ç‚º [1;32m%s[m", cu->chatid, topic);
    send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  }
}


static void
chat_version(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char buf[80];

  sprintf(buf, "%d %d", XCHAT_VERSION_MAJOR, XCHAT_VERSION_MINOR);
  send_to_user(cu, buf, 0, MSG_VERSION);
}


static void
chat_nick(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *chatid, *str, buf[128];
  ChatUser *xuser;

#ifdef HAVE_KILL_GAME
  if(cu->room->rflag & ROOM_KILL_STARTED)
  {
    send_to_user(cu, "â€» æ®ºæ‰‹éŠæˆ²é€²è¡Œä¸­ï¼Œä¸èƒ½æ›´æ”¹ID", 0, MSG_MESSAGE);
    return;
  }
#endif

  chatid = nextword(&msg);
  chatid[8] = '\0';
  if (!valid_chatid(chatid))
  {
    send_to_user(cu, "â€» é€™å€‹èŠå¤©ä»£è™Ÿæ˜¯ä¸æ­£ç¢ºçš„", 0, MSG_MESSAGE);
    return;
  }

  xuser = cuser_by_chatid(chatid);
  if (xuser != NULL && xuser != cu)
  {
    send_to_user(cu, "â€» å·²ç¶“æœ‰äººæ·è¶³å…ˆç™»å›‰", 0, MSG_MESSAGE);
    return;
  }

  str = cu->chatid;

  /* fuse.991210: æ”¹ä»£è™Ÿé€™ç¨®äº‹quietæ¨¡å¼ä¸‹ä¸è¦é¡¯ç¤ºäº† */
  if ((!CLOAK(cu)) && (!INTERVIEW(cu->room)))
  {
    sprintf(buf, "â€» %s å°‡èŠå¤©ä»£è™Ÿæ”¹ç‚º [1;33m%s[m", str, chatid);
    send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,NULL);
  }

  strcpy(str, chatid);

  user_changed(cu);

  if (cu->clitype)
  {
    send_to_user(cu, chatid, 0, MSG_NICK);
  }
  else
  {
    sprintf(buf, "/n%s", chatid);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }
}


static void
chat_list_rooms(cuser, msg)
  ChatUser *cuser;
  char *msg;
{
  ChatRoom *cr, *room;
  char buf[128];
  int mode;

  if (RESTRICTED(cuser))
  {
    send_to_user(cuser, "â€» æ‚¨æ²’æœ‰æ¬Šé™åˆ—å‡ºç¾æœ‰çš„èŠå¤©å®¤", 0, MSG_MESSAGE);
    return;
  }

  mode = common_client_command;

  if (mode)
    send_to_user(cuser, "", 0, MSG_ROOMLISTSTART);
  else
    send_to_user(cuser, "[7m è«‡å¤©å®¤åç¨±  â”‚äººæ•¸â”‚è©±é¡Œ        [m", 0,
      MSG_MESSAGE);

  room = cuser->room;
  cr = &mainroom;

  do
  {
    if ((cr == room) || !SECRET(cr) || CHATSYSOP(cuser))
    {
      if (mode)
      {
    sprintf(buf, "%s %d %d %s",
      cr->name, cr->occupants, cr->rflag, cr->topic);
    send_to_user(cuser, buf, 0, MSG_ROOMLIST);
      }
      else
      {
    sprintf(buf, " %-12sâ”‚%4dâ”‚%s", cr->name, cr->occupants, cr->topic);
    if (LOCKED(cr))
      strcat(buf, " [é–ä½]");
    if (SECRET(cr))
      strcat(buf, " [ç§˜å¯†]");
    if (OPENTOPIC(cr))
      strcat(buf, " [è©±é¡Œ]");
    send_to_user(cuser, buf, 0, MSG_MESSAGE);
      }
    }
  } while (cr = cr->next);

  if (mode)
    send_to_user(cuser, "", 0, MSG_ROOMLISTEND);
}


static void
chat_do_user_list(cu, msg, theroom)
  ChatUser *cu;
  char *msg;
  ChatRoom *theroom;
{
  ChatRoom *myroom, *room;
  ChatUser *user;
  int start, stop, curr, mode; /* , uflag; */
  char buf[128];

  curr = 0; /* Thor.980619: initialize curr */
  start = atoi(nextword(&msg));
  stop = atoi(nextword(&msg));

  mode = common_client_command;

  if (mode)
    send_to_user(cu, "", 0, MSG_USERLISTSTART);
  else
    send_to_user(cu, "[7m èŠå¤©ä»£è™Ÿâ”‚ä½¿ç”¨è€…ä»£è™Ÿ  â”‚èŠå¤©å®¤ [m", 0,
      MSG_MESSAGE);

  myroom = cu->room;

  /* Thor.980717: éœ€è¦å…ˆæ’é™¤ cu->userno == 0 çš„ç‹€æ³å—? */
  for (user = mainuser; user; user = user->unext)
  {
    /*
    if (!cu->userno)
      continue;
     */ /* Thor.980717: æ—¢ç„¶ cu éƒ½ç©ºäº†é‚£é‚„é€²ä¾†å¹¹éº¼? */
    if (!user->userno)
      continue;

    room = user->room;
    if ((theroom != ROOM_ALL) && (theroom != room))
      continue;

#if 0
    uflag = user->uflag;
    if ((myroom != room) && (!uflag ||
    (room && SECRET(room) && !(uflag & (PERM_SYSOP | PERM_CHATROOM)))))
      continue;

    if ((uflag & PERM_CLOAK) && (user != cu) &&
      !(uflag & (PERM_SYSOP | PERM_CHATROOM)))
      continue;
#endif
    /* Thor.980717:ä¸Šè¿°logicæœ‰èª¤ */

    /* Thor.980717: viewer check */
    if ((myroom != room) && (RESTRICTED(cu) ||
                             (room && SECRET(room) && !CHATSYSOP(cu))))
      continue;

    /* Thor.980717: viewee check */
    if (CLOAK(user) && (user != cu) && !CHATSYSOP(cu))
      continue;
    /* Thor.980717:é‡å¯«*/


    curr++;
    if (start && curr < start)
      continue;
    else if (stop && (curr > stop))
      break;

    if (mode)
    {
      if (!room)
    continue;       /* Xshadow: é‚„æ²’é€²å…¥ä»»ä½•æˆ¿é–“çš„å°±ä¸åˆ—å‡º */

      sprintf(buf, "%s %s %s %s",
    user->chatid, user->userid, room->name, user->rhost);
/* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— */
/*       if (uflag & (PERM_ROOMOP | PERM_SYSOP | PERM_CHATROOM)) */
      if (ROOMOP(user))
    strcat(buf, " Op");
    }
    else
    {
      sprintf(buf, " %-8sâ”‚%-12sâ”‚%s",
    user->chatid, user->userid, room ? room->name : "[åœ¨é–€å£å¾˜å¾Š]");
/* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— */
/*       if (uflag & (PERM_ROOMOP | PERM_SYSOP | PERM_CHATROOM)) */
      /* if (uflag & (PERM_ROOMOP|PERM_CHATOP)) */
      if (ROOMOP(user))  /* Thor.980602: çµ±ä¸€ç”¨æ³• */
    strcat(buf, " [Op]");
    }

    send_to_user(cu, buf, 0, mode ? MSG_USERLIST : MSG_MESSAGE);
  }

  if (mode)
    send_to_user(cu, "", 0, MSG_USERLISTEND);
}


static void
chat_list_by_room(cu, msg)
  ChatUser *cu;
  char *msg;
{
  ChatRoom *whichroom;
  char *roomstr, buf[128];

  roomstr = nextword(&msg);
  if (!*roomstr)
  {
    whichroom = cu->room;
  }
  else
  {
    if (!(whichroom = croom_by_roomid(roomstr)))
    {
      sprintf(buf, "â€» æ²’æœ‰ [%s] é€™å€‹èŠå¤©å®¤", roomstr);
      send_to_user(cu, buf, 0, MSG_MESSAGE);
      return;
    }

    if (whichroom != cu->room && SECRET(whichroom) && !CHATSYSOP(cu))
    {
      send_to_user(cu, "â€» ç„¡æ³•åˆ—å‡ºåœ¨ç§˜å¯†èŠå¤©å®¤çš„ä½¿ç”¨è€…", 0, MSG_MESSAGE);
      return;
    }
  }
  chat_do_user_list(cu, msg, whichroom);
}


static void
chat_list_users(cu, msg)
  ChatUser *cu;
  char *msg;
{
  chat_do_user_list(cu, msg, ROOM_ALL);
}


static void
chat_chatroom(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (common_client_command)
    send_to_user(cu, "çœŸæƒ…æµéœ²èŠå¤©å»£å ´", 0, MSG_CHATROOM);
}


static void
chat_map_chatids(cu, whichroom)
  ChatUser *cu;         /* Thor: é‚„æ²’æœ‰ä½œä¸åŒé–“çš„ */
  ChatRoom *whichroom;
{
  int c;
  ChatRoom *myroom, *room;
  ChatUser *user;
  char buf[128];

  myroom = cu->room;

#ifdef HAVE_KILL_GAME
    if (whichroom != ROOM_ALL && whichroom->rflag & (ROOM_KILLGAME | ROOM_KILL_
STARTED) )
      send_to_user(cu,
    "[7m èŠå¤©ä»£è™Ÿ è§’è‰²        â”‚ èŠå¤©ä»£è™Ÿ è§’è‰²        â”‚ èŠå¤©ä»£è™Ÿ è§’è‰²       [m", 0,
 MSG_MESSAGE);
    else
#endif
  send_to_user(cu,
    "[7m èŠå¤©ä»£è™Ÿ ä½¿ç”¨è€…ä»£è™Ÿ  â”‚ èŠå¤©ä»£è™Ÿ ä½¿ç”¨è€…ä»£è™Ÿ  â”‚ èŠå¤©ä»£è™Ÿ ä½¿ç”¨è€…ä»£è™Ÿ [m", 0,
 MSG_MESSAGE);

  for (c = 0, user = mainuser; user; user = user->unext)
  {
    if (!cu->userno)
      continue;

    room = user->room;
    if (whichroom != ROOM_ALL && whichroom != room)
      continue;

    if (myroom != room)
    {
      if (RESTRICTED(cu) || /* Thor: è¦å…ˆcheck room æ˜¯ä¸æ˜¯ç©ºçš„ */
    (room && SECRET(room) && !CHATSYSOP(cu)))
    continue;
    }

    if (CLOAK(user) && (user != cu) && !CHATSYSOP(cu))  /* Thor:éš±èº«æœ® */
      continue;

#ifdef HAVE_KILL_GAME
    if (whichroom != ROOM_ALL && whichroom->rflag & (ROOM_KILLGAME | ROOM_KILL_STARTED))
      sprintf(buf + (c * 24), " %-8s%c%-12s%s",
        user->chatid, ROOMOP(user) ? '*' : ' ',
        userkillstates[kill_get_user_state(whichroom,cu,user)], (c < 2 ? "â”‚" : "  "));
    else
      sprintf(buf + (c * 24), " %-8s%c%-12s%s",
        user->chatid, ROOMOP(user) ? '*' : ' ',
        user->userid, (c < 2 ? "â”‚" : "  "));
#else
    sprintf(buf + (c * 24), " %-8s%c%-12s%s",
      user->chatid, ROOMOP(user) ? '*' : ' ',
      user->userid, (c < 2 ? "â”‚" : "  "));
#endif

    if (++c == 3)
    {
      send_to_user(cu, buf, 0, MSG_MESSAGE);
      c = 0;
    }
  }

  if (c > 0)
    send_to_user(cu, buf, 0, MSG_MESSAGE);
}


static void
chat_map_chatids_thisroom(cu, msg)
  ChatUser *cu;
  char *msg;
{
  chat_map_chatids(cu, cu->room);
}


static void
chat_setroom(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *modestr;
  ChatRoom *room;
  char *chatid;
  int sign, flag;
  char *fstr, buf[128];

  if (!ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  modestr = nextword(&msg);
  sign = 1;
  if (*modestr == '+')
  {
    modestr++;
  }
  else if (*modestr == '-')
  {
    modestr++;
    sign = 0;
  }

  if (*modestr == '\0')
  {
    send_to_user(cu,
      "â€» è«‹æŒ‡å®šç‹€æ…‹: {[+(è¨­å®š)][-(å–æ¶ˆ)]}{[L(é–ä½)][s(ç§˜å¯†)][t(é–‹æ”¾è©±é¡Œ)}", 0,
 MSG_MESSAGE);
    return;
  }

  room = cu->room;
  chatid = cu->chatid;

  while (*modestr)
  {
    flag = 0;
    switch (*modestr)
    {
    case 'l':
    case 'L':
      flag = ROOM_LOCKED;
      fstr = "é–ä½";
      break;

    case 's':
    case 'S':
      flag = ROOM_SECRET;
      fstr = "ç§˜å¯†";
      break;

    case 't':
    case 'T':
      flag = ROOM_OPENTOPIC;
      fstr = "é–‹æ”¾è©±é¡Œ";
      break;

    /* fuse.991210: æ¸…éœèŠå¤©å®¤ */
    case 'q':
    case 'Q':
      flag = ROOM_QUIET;
      fstr = "æ¸…éœèŠå¤©å®¤";
      break;

    case 'i':
    case 'I':
      flag = ROOM_INTERVIEW;
      fstr = "è²´è³“å°ˆè¨ª";
      break;

    default:
      sprintf(buf, "â€» ç‹€æ…‹éŒ¯èª¤ï¼š[%c]", *modestr);
      send_to_user(cu, buf, 0, MSG_MESSAGE);
    }

    /* Thor: check room æ˜¯ä¸æ˜¯ç©ºçš„, æ‡‰è©²ä¸æ˜¯ç©ºçš„ */

    if (flag && (room->rflag & flag) != sign * flag)
    {
      room->rflag ^= flag;

      if (!CLOAK(cu))
      {
    sprintf(buf, "â€» æœ¬èŠå¤©å®¤è¢« %s %s [%s] ç‹€æ…‹",
      chatid, sign ? "è¨­å®šç‚º" : "å–æ¶ˆ", fstr);
    send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
      }
    }
    modestr++;
  }

  /* Thor.980602: ä¸å‡† Main room é–èµ· or ç§˜å¯†, é€™æˆä½•é«”çµ±?
                  é›¢é–‹çš„å°±é€²ä¸ä¾†, è¦çœ‹ä¹Ÿçœ‹ä¸åˆ°?
                  æƒ³è¦è¸¢äººä¹Ÿè¸¢ä¸é€² main room, ä¸æœƒå¾ˆå¥‡æ€ªå—? */
  if(str_equal(MAIN_NAME, room->name))
  {
    if(room->rflag & (ROOM_LOCKED | ROOM_SECRET))
    {
        send_to_room(room, "â€» ä½† çœŸæƒ…ä½¿è€… æ–½äº†ã€å¾©åŸã€çš„é­”æ³•", 0, MSG_MESSAGE,
NULL);
        room->rflag &= ~(ROOM_LOCKED|ROOM_SECRET);
    }
  }

  room_changed(room);
}


static char *chat_msg[] =
{
  "[//]help", "MUD-like ç¤¾äº¤å‹•è©",
  "[/h]elp op", "è«‡å¤©å®¤ç®¡ç†å“¡å°ˆç”¨æŒ‡ä»¤",
#ifdef HAVE_KILL_GAME
  "[/h]elp ki","æ®ºæ‰‹éŠæˆ²å°ˆç”¨æŒ‡ä»¤",
#endif
  "[/a]ct <msg>", "åšä¸€å€‹å‹•ä½œ",
  "[/b]ye [msg]", "é“åˆ¥",
  "[/c]lear  [/d]ate", "æ¸…é™¤è¢å¹•  ç›®å‰æ™‚é–“",
  /*"[/d]ate", "ç›®å‰æ™‚é–“", *//* Thor: æŒ‡ä»¤å¤ªå¤š */

#if 0
  "[/f]ire <user> <msg>", "ç™¼é€ç†±è¨Š",   /* Thor.0727: å’Œ flag æ²–key */
#endif

  "[/ignore] [user]", "å¿½ç•¥ä½¿ç”¨è€…",
  "[/i]nvite [user]", "é‚€è«‹ä½¿ç”¨è€…",
  "[/j]oin <room>", "å»ºç«‹æˆ–åŠ å…¥è«‡å¤©å®¤",
  "[/l]ist [start [stop]]", "åˆ—å‡ºè«‡å¤©å®¤ä½¿ç”¨è€…",
  "[/m]sg <id|user> <msg>", "è·Ÿ <id> èªªæ‚„æ‚„è©±",
  "[/n]ick <id>", "å°‡è«‡å¤©ä»£è™Ÿæ›æˆ <id>",
  "[/p]ager", "åˆ‡æ›å‘¼å«å™¨",
  "[/q]uery <user>", "æŸ¥è©¢ç¶²å‹",
  "[/r]oom", "åˆ—å‡ºä¸€èˆ¬è«‡å¤©å®¤",
  "[/t]ape", "é–‹é—œéŒ„éŸ³æ©Ÿ",
  "[/to] <user>", "å°ä½¿ç”¨è€…èªª!",
  "[/unignore] <user>", "å–æ¶ˆå¿½ç•¥",

#if 0
  "[/u]sers", "åˆ—å‡ºç«™ä¸Šä½¿ç”¨è€…",
#endif

  "[/w]ho", "åˆ—å‡ºæœ¬è«‡å¤©å®¤ä½¿ç”¨è€…",
  "[/w]hoin <room>", "åˆ—å‡ºè«‡å¤©å®¤<room> çš„ä½¿ç”¨è€…",
  NULL
};


static char *room_msg[] =
{
  "[/f]lag [+-][lst]", "è¨­å®šé–å®šã€ç§˜å¯†ã€é–‹æ”¾è©±é¡Œ",
  "[/i]nvite <id>", "é‚€è«‹ <id> åŠ å…¥è«‡å¤©å®¤",
  "[/kick] <id>", "å°‡ <id> è¸¢å‡ºè«‡å¤©å®¤",
  "[/o]p [<id>]", "å°‡ Op çš„æ¬ŠåŠ›è½‰ç§»çµ¦ <id>",
  "[/topic] <text>", "æ›å€‹è©±é¡Œ",
  "[/w]all", "å»£æ’­ (ç«™é•·å°ˆç”¨)",
  NULL
};

#ifdef HAVE_KILL_GAME
static char* kill_msg[] =
{
  "[/jk]ill <room>", "å»ºç«‹æˆ–åŠ å…¥æ®ºæ‰‹éŠæˆ²è«‡å¤©å®¤",

  "[/ks]tart ...","é–‹å§‹æ®ºæ‰‹éŠæˆ²(OPå°ˆç”¨),åƒæ•¸å¦‚ä¸‹ï¼Œä»¥ç©ºæ ¼åˆ†éš”",
  "    police","å¼·åˆ¶å‡ºç¾è­¦å¯Ÿ",
  "    nopolice","å¼·åˆ¶ä¸å‡ºç¾è­¦å¯Ÿ",
  "    discuss","å…è¨±è¼ªæµç™¼è¨€æ™‚å¤§å®¶æ’å˜´",
  "    noghost","æ­»äººä¸èƒ½éš¨æ„ç™¼è¨€",
  "    strpolice","è­¦å¯Ÿæ¯å›åˆç™¼ç¾ä¸€å€‹æ®ºæ‰‹ï¼ˆæ®ºæ‰‹æŠ•ç¥¨å)",
  "[/ke]nd","çµæŸæ®ºæ‰‹éŠæˆ²(OPå°ˆç”¨)",
  "[/kill] <user>","æ®ºæ‰‹éŠæˆ²ä¸­è™•æ±ºä¸€å€‹äººï¼Œå±¬äºæŠ•ç¥¨æ€§è³ª",
  "[/kq]uery]","æ®ºæ‰‹éŠæˆ²ä¸­è­¦å¯ŸæŸ¥è©¢ä¸€å€‹äººçš„çœŸå¯¦èº«ä»½",
  "[/ko]ver]","æ®ºæ‰‹éŠæˆ²ä¸­èªç‚ºè‡ªå·±æœ¬è¼ªä»»å‹™å·²å®Œæˆï¼Œå¦‚æŸ¥çœ‹å’Œç™¼è¨€",
  "[/kkk]","æ®ºæ‰‹éŠæˆ²ä¸­è§¸ç™¼æ™‚é–“æª¢æŸ¥ï¼Œä»»ä½•äººéƒ½å¯ä½¿ç”¨ï¼ŒåŒ…æ‹¬æ­»äºº",
  NULL

};
#endif

static void
chat_help(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char **table, *str, buf[128];

  if (str_equal("op", nextword(&msg)))
  {
    send_to_user(cu, "è«‡å¤©å®¤ç®¡ç†å“¡å°ˆç”¨æŒ‡ä»¤", 0, MSG_MESSAGE);
    table = room_msg;
  }
#ifdef HAVE_KILL_GAME
  else if (!str_cmp("ki", nextword(&msg)))
  {
    send_to_user(cu, "æ®ºæ‰‹éŠæˆ²å°ˆç”¨æŒ‡ä»¤",0,MSG_MESSAGE);
    table = kill_msg;
  }
#endif
  else
  {
    table = chat_msg;
  }

  while (str = *table++)
  {
    sprintf(buf, "  %-20s- %s", str, *table++);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }
}


static void
chat_private(cu, msg)
  ChatUser *cu;
  char *msg;
{
  ChatUser *xuser;
  int userno;
  char *recipient, buf[128];

  userno = 0;
  recipient = nextword(&msg);

  if (strcmp(recipient, interviewer) == 0)
  {
    /* è¢«é‡‡è¨ªäººä¸æ¥å—è¨Šæ¯ */
    if (INTERVIEW(cu->room) && (!(ROOMOP(cu))))
       return;
  }

  xuser = (ChatUser *) fuzzy_cuser_by_chatid(recipient);
  if (xuser == NULL)        /* Thor.0724: ç”¨ useridä¹Ÿå¯å‚³æ‚„æ‚„è©± */
  {
    xuser = cuser_by_userid(recipient);
  }

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, recipient);
  }
  else if (xuser == FUZZY_USER)
  {             /* ambiguous */
    strcpy(buf, "â€» è«‹æŒ‡æ˜èŠå¤©ä»£è™Ÿ");
  }
  else if (*msg)
  {
#ifdef HAVE_KILL_GAME
    if(cu->room == xuser->room)
    {
      if(cu->room->rflag & ROOM_KILL_STARTED)
      {
        if(KILL_ROLE(cu) != KILL_KILLER || KILL_ROLE(xuser) != KILL_KILLER)
        {
          send_to_user(cu,"\033[1;33m$$ éŠæˆ²ä¸­ä¸èƒ½èªªæ‚„æ‚„è©±ï¼\033[m", 
            0, MSG_MESSAGE);
          return;
        }
      }
    }
#endif
    userno = cu->userno;
    sprintf(buf, "[1m*%s*[m ", cu->chatid);
    msg[79] = 0;        /* Thor:é˜²æ­¢å¤ªé•· */
    strncat(buf, msg, 80);
    send_to_user(xuser, buf, userno, MSG_MESSAGE);

    if (xuser->clitype)
    {               /* Xshadow: å¦‚æœå°æ–¹æ˜¯ç”¨ client ä¸Šä¾†çš„ */
      sprintf(buf, "%s %s ", cu->userid, cu->chatid);
      msg[79] = 0;
      strncat(buf, msg, 80);
      send_to_user(xuser, buf, userno, MSG_PRIVMSG);
    }

    if (cu->clitype)
    {
      sprintf(buf, "%s %s ", xuser->userid, xuser->chatid);
      msg[79] = 0;
      strncat(buf, msg, 80);
      send_to_user(cu, buf, 0, MSG_MYPRIVMSG);
    }

    sprintf(buf, "%s> ", xuser->chatid);
    strncat(buf, msg, 80);
  }
  else
  {
    sprintf(buf, "â€» æ‚¨æƒ³å° %s èªªä»€éº¼è©±å‘¢ï¼Ÿ", xuser->chatid);
  }

  send_to_user(cu, buf, userno, MSG_MESSAGE);

  /* Thor: userno è¦æ”¹æˆ 0 å—? */
}


static void
chat_cloak(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (CHATSYSOP(cu))
  {
    char buf[128];

    cu->uflag ^= PERM_CLOAK;
    sprintf(buf, "â—† %s", CLOAK(cu) ? MSG_CLOAKED : MSG_UNCLOAK);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }
}


/* ----------------------------------------------------- */


static void
arrive_room(cuser, room)
  ChatUser *cuser;
  ChatRoom *room;
{
  char *rname, buf[1024];


  /* Xshadow: ä¸å¿…é€çµ¦è‡ªå·±, åæ­£æ›æˆ¿é–“å°±æœƒé‡æ–° build user list */

  sprintf(buf, "+ %s %s %s %s",
    cuser->userid, cuser->chatid, room->name, cuser->rhost);
  if (ROOMOP(cuser))
    strcat(buf, " Op");
  send_to_room(room, buf, 0, MSG_USERNOTIFY,NULL);

  room->occupants++;
  room_changed(room);

  cuser->room = room;
  rname = room->name;

  if (cuser->clitype)
  {
    send_to_user(cuser, rname, 0, MSG_ROOM);
    send_to_user(cuser, room->topic, 0, MSG_TOPIC);
  }
  else
  {
    sprintf(buf, "/r%s", rname);
    send_to_user(cuser, buf, 0, MSG_MESSAGE);
    sprintf(buf, "/t%s", room->topic);
    send_to_user(cuser, buf, 0, MSG_MESSAGE);
#ifdef HAVE_KILL_GAME
    if(room->rflag & ROOM_KILLGAME)
    {
      sprintf(buf,"/k6");
      send_to_user(cuser, buf, 0, MSG_MESSAGE);
      sprintf(buf,"/u5 %s",MSG_SEPERATOR);
      send_to_user(cuser, buf, 0, MSG_MESSAGE);

    }
    else
    {
      sprintf(buf,"/k2");
      send_to_user(cuser,buf,0,MSG_MESSAGE);
    }
#endif
  }


  /* fuse.991210: INTERVIEWæ¨¡å¼ä¸‹é€²å…¥ä¸é¡¯ç¤ºäº† */
  if (!INTERVIEW(cuser->room))
    sprintf(buf, "â€» [32;1m%s[m é€²å…¥ [33;1m[%s][m åŒ…å»‚",
      cuser->chatid, rname);

  if (!CLOAK(cuser))
    send_to_room(room, buf, cuser->userno, MSG_MESSAGE,NULL);
  else
    send_to_user(cuser, buf, 0, MSG_MESSAGE);
}


static int
enter_room(cuser, rname, msg, crflag)
  ChatUser *cuser;
  char *rname;
  char *msg;
  int crflag;
{
  ChatRoom *room;
  int create;
  char buf[256];

  create = 0;
  room = croom_by_roomid(rname);

  if (room == NULL)
  {
    /* new room */

#ifdef DEBUG
    logit(cuser->userid, "create new room");
    debug_room();
#endif

    if (room = roompool)
    {
      roompool = room->next;
    }
    else
    {
      room = (ChatRoom *) malloc(sizeof(ChatRoom));
    }

    if (room == NULL)
    {
      send_to_user(cuser, "â€» ç„¡æ³•å†æ–°è¾ŸåŒ…å»‚äº†", 0, MSG_MESSAGE);
      return 0;
    }

    memset(room, 0, sizeof(ChatRoom));
    /* str_ncpy(room->name, rname, IDLEN - 1); */
    str_ncpy(room->name, rname, IDLEN);
    /* Thor.980921: å·²åŒ…å« 0 */
    strcpy(room->topic, "é€™æ˜¯ä¸€å€‹æ–°å¤©åœ°");
#ifdef HAVE_KILL_GAME
    if(crflag & ROOM_KILLGAME)
    {
      strcat(room->topic,"K");
      room->rflag |= ROOM_KILLGAME;
    }
#endif

    sprintf(buf, "+ %s 1 0 %s", room->name, room->topic);
    send_to_room(ROOM_ALL, buf, 0, MSG_ROOMNOTIFY,NULL);

    if (mainroom.next)
      mainroom.next->prev = room;
    room->next = mainroom.next;

    mainroom.next = room;
    room->prev = &mainroom;

#ifdef DEBUG
    logit(cuser->userid, "create room succeed");
    debug_room();
#endif

    create = 1;
    fprintf(flog, "room+\t[%d] %s\n", cuser->sno, rname);
  }
  else
  {
#ifdef HAVE_KILL_GAME
    if(crflag & ROOM_KILLGAME)
    {
      if(!(room->rflag & ROOM_KILLGAME))
      {
        send_to_user(cuser,"â€» é€™å€‹èŠå¤©å®¤ä¸æ˜¯æ®ºæ‰‹éŠæˆ²å®¤",0,MSG_MESSAGE);
        return 0;
      }

      if(room->rflag & ROOM_KILL_STARTED)
      {
        send_to_user(cuser,"â€» é€™å€‹èŠå¤©å®¤çš„éŠæˆ²å·²ç¶“é–‹å§‹äº†:(",0,MSG_MESSAGE);
        return 0;
      }
    }
#endif
    if (cuser->room == room)
    {
      sprintf(buf, "â€» æ‚¨æœ¬ä¾†å°±åœ¨ [%s] èŠå¤©å®¤å›‰ :)", rname);
      send_to_user(cuser, buf, 0, MSG_MESSAGE);
      return 0;
    }

#ifdef HAVE_KILL_GAME
      if(room->rflag & ROOM_KILLGAME && room->rflag & ROOM_KILL_STARTED)
      {
        send_to_user(cuser,"â€» é€™å€‹èŠå¤©å®¤è£¡æ­£åœ¨é€²è¡ŒéŠæˆ²",0,MSG_MESSAGE);
        return 0;
      }
#endif

    if (!CHATSYSOP(cuser) && LOCKED(room) &&
      !list_belong(room->invite, cuser->userno))
    {
      send_to_user(cuser, "â€» å…§æœ‰æƒ¡çŠ¬ï¼Œéè«‹è«å…¥", 0, MSG_MESSAGE);
      return 0;
    }
  }

  exit_room(cuser, EXIT_LOGOUT, msg);
  arrive_room(cuser, room);

  if (create)
    cuser->uflag |= PERM_ROOMOP;

  return 0;
}


static void
cuser_free(cuser)
  ChatUser *cuser;
{
  int sock;

  sock = cuser->sock;
  shutdown(sock, 2);
  close(sock);

  FD_CLR(sock, &mainfset);

  list_free(&cuser->ignore);
  totaluser--;

  if (cuser->room)
  {
    exit_room(cuser, EXIT_LOSTCONN, NULL);
  }

  fprintf(flog, "BYE\t[%d] T%d X%d\n",
    cuser->sno, time(0) - cuser->tbegin, cuser->xdata);
}


static void
print_user_counts(cuser)
  ChatUser *cuser;
{
  ChatRoom *room;
  int num, userc, suserc, roomc, number;
  char buf[256];

  userc = suserc = roomc = 0;

  room = &mainroom;
  do
  {
    num = room->occupants;
    if (SECRET(room))
    {
      suserc += num;
      if (CHATSYSOP(cuser))
    roomc++;
    }
    else
    {
      userc += num;
      roomc++;
    }
  } while (room = room->next);

  number = (cuser->clitype) ? MSG_MOTD : MSG_MESSAGE;

  sprintf(buf,
    "âŠ™ æ­¡è¿å…‰è‡¨ã€çœŸæƒ…èŠå¤©å®¤ã€‘ï¼Œç›®å‰é–‹äº† [1;31m%d[m é–“åŒ…å»‚", roomc);
  send_to_user(cuser, buf, 0, number);

  sprintf(buf, "âŠ™ å…±æœ‰ [1;36m%d[m äººä¾†æ“ºé¾é–€é™£", userc);
  if (suserc)
    sprintf(buf + strlen(buf), " [%d äººåœ¨ç§˜å¯†èŠå¤©å®¤]", suserc);

  send_to_user(cuser, buf, 0, number);
}


static int
login_user(cu, msg)
  ChatUser *cu;
  char *msg;
{
  int utent;

  char *userid;
  char *chatid, *passwd;
  ChatUser *xuser;
  int level;
/*   struct hostent *hp; */

#ifndef STAND_ALONE
  ACCT acct;
#endif

  /* Xshadow.0915: common client support : /-! userid chatid password */
  /* client/server ç‰ˆæœ¬ä¾æ“š userid æŠ“ .PASSWDS åˆ¤æ–· userlevel */

  userid = nextword(&msg);
  chatid = nextword(&msg);

#ifdef  DEBUG
  logit("ENTER", userid);
#endif

#ifndef STAND_ALONE
  /* Thor.0730: parse space before passwd */

  passwd = msg;

  /* Thor.0813: è·³éä¸€ç©ºæ ¼å³å¯, å› ç‚ºåæ­£å¦‚æœchatidæœ‰ç©ºæ ¼, å¯†ç¢¼ä¹Ÿä¸å° */
  /* å°±ç®—å¯†ç¢¼å°, ä¹Ÿä¸æœƒæ€éº¼æ¨£:p */
  /* å¯æ˜¯å¦‚æœå¯†ç¢¼ç¬¬ä¸€å€‹å­—æ˜¯ç©ºæ ¼, é‚£è·³å¤ªå¤šç©ºæ ¼æœƒé€²ä¸ä¾†... */
  /* Thor.980910: ç”±æ–¼ nextwordä¿®æ”¹ç‚ºå¾Œæ¥ç©ºæ ¼å¡«0, å‚³å…¥å€¼å‰‡ç›´æ¥å¾Œç§»è‡³0å¾Œ,
                  æ‰€ä»¥ä¸éœ€ä½œæ­¤å‹•ä½œ */
#if 0
  if (*passwd == ' ')
    passwd++;
#endif

  /* Thor.0729: load acct */

  if (!*userid || (acct_load(&acct, userid) < 0))
  {

#ifdef  DEBUG
    logit("noexist", userid);
#endif

    if (cu->clitype)
      send_to_user(cu, "éŒ¯èª¤çš„ä½¿ç”¨è€…ä»£è™Ÿ", 0, ERR_LOGIN_NOSUCHUSER);
    else
      send_to_user(cu, CHAT_LOGIN_INVALID, 0, MSG_MESSAGE);

    return -1;
  }

  /* Thor.0813: æ”¹ç”¨çœŸå¯¦ password check, for C/S bbs */

  /* Thor.990214: æ³¨æ„,daolibä¸­ é0ä»£è¡¨å¤±æ•— */
  /* if (!chkpasswd(acct.passwd, passwd)) */
  if (chkpasswd(acct.passwd, passwd))
  {

#ifdef  DEBUG
    logit("fake", userid);
#endif

    if (cu->clitype)
      send_to_user(cu, "å¯†ç¢¼éŒ¯èª¤", 0, ERR_LOGIN_PASSERROR);
    else
      send_to_user(cu, CHAT_LOGIN_INVALID, 0, MSG_MESSAGE);

    return -1;
  }

  level = acct.userlevel;
  utent = acct.userno;

#else               /* STAND_ALONE */
  level = 1;
  utent = ++userno_inc;
#endif              /* STAND_ALONE */

  /* Thor.0819: for client/server bbs */

#ifdef DEBUG
  log_user(NULL);
#endif

  for (xuser = mainuser; xuser; xuser = xuser->unext)
  {

#ifdef DEBUG
    log_user(xuser);
#endif

    if (xuser->userno == utent)
    {

#ifdef  DEBUG
      logit("enter", "bogus");
#endif

#ifdef HAVE_KILL_GAME
      if(xuser->killflag &= KILL_DROPED)
      {
        char buf[128];
        xuser->sock = cu->sock;
        xuser->clitype = cu->clitype;

        totaluser --;

        cu->unext = userpool;
        userpool = cu;

        xuser->room->occupants ++;

        sprintf(buf,"\033[1;33m$$ $$ æ­¡è¿ %s å›ä¾†ç¹¼çºŒéŠæˆ² $$ $$",xuser->chatid)
;
        send_to_room(xuser->room,buf,0,MSG_MESSAGE,NULL);

        xuser->killflag &= ~KILL_DROPED;

        kill_on_reconnect(xuser->room);
      }
      else
      {
        if (cu->clitype)
      send_to_user(cu, "è«‹å‹¿æ´¾é£åˆ†èº«é€²å…¥èŠå¤©å®¤ !!", 0,
        ERR_LOGIN_USERONLINE);
        else
      send_to_user(cu, CHAT_LOGIN_BOGUS, 0, MSG_MESSAGE);
        return -1;      /* Thor: æˆ–æ˜¯0ç­‰å®ƒè‡ªå·±äº†æ–·? */
      }
#else
        if (cu->clitype)
      send_to_user(cu, "è«‹å‹¿æ´¾é£åˆ†èº«é€²å…¥èŠå¤©å®¤ !!", 0,
        ERR_LOGIN_USERONLINE);
        else
      send_to_user(cu, CHAT_LOGIN_BOGUS, 0, MSG_MESSAGE);
        return -1;      /* Thor: æˆ–æ˜¯0ç­‰å®ƒè‡ªå·±äº†æ–·? */
#endif
    }
  }


#ifndef STAND_ALONE
  /* Thor.980629: æš«æ™‚å€Ÿç”¨ invalid_chatid æ¿¾é™¤ æ²’æœ‰PERM_CHATçš„äºº */

  if (!valid_chatid(chatid) || !(level & PERM_CHAT) || (level & PERM_DENYCHAT))
  { /* Thor.981012: å¾¹åº•ä¸€äº›, é€£ denychatä¹ŸBANæ‰, å…å¾— clientä½œæ€ª */

#ifdef  DEBUG
    logit("enter", chatid);
#endif

    if (cu->clitype)
      send_to_user(cu, "ä¸åˆæ³•çš„èŠå¤©å®¤ä»£è™Ÿ !!", 0, ERR_LOGIN_NICKERROR);
    else
      send_to_user(cu, CHAT_LOGIN_INVALID, 0, MSG_MESSAGE);
    return 0;
  }
#endif

#ifdef  DEBUG
  debug_user();
#endif

  if (cuser_by_chatid(chatid) != NULL)
  {
    /* chatid in use */

#ifdef  DEBUG
    logit("enter", "duplicate");
#endif

    if (cu->clitype)
      send_to_user(cu, "é€™å€‹ä»£è™Ÿå·²ç¶“æœ‰äººä½¿ç”¨", 0, ERR_LOGIN_NICKINUSE);
    else
      send_to_user(cu, CHAT_LOGIN_EXISTS, 0, MSG_MESSAGE);
    return 0;
  }

#ifdef DEBUG            /* CHATSYSOP ä¸€é€²ä¾†å°±éš±èº« */
  cu->uflag = level & ~(PERM_ROOMOP | PERM_CHATOP | (CHATSYSOP(cu) ? 0 : PERM_C
LOAK));
#else
  cu->uflag = level & ~(PERM_ROOMOP | PERM_CHATOP | PERM_CLOAK);
#endif

  /* Thor: é€²ä¾†å…ˆæ¸…ç©º ROOMOP (åŒPERM_CHAT) */

  strcpy(cu->userid, userid);
  str_ncpy(cu->chatid, chatid, sizeof(cu->chatid));
  /* Thor.980921: str_ncpyèˆ‡ä¸€èˆ¬ strncpyæœ‰æ‰€ä¸åŒ, ç‰¹åˆ¥æ³¨æ„ */

  /* Thor.980921: é˜²æ­¢å¤ªé•· */
  /* cu->chatid[8]=0; */

  fprintf(flog, "ENTER\t[%d] %s\n", cu->sno, userid);

  /* Xshadow: å–å¾— client çš„ä¾†æº */

  dns_name(cu->rhost, cu->ibuf);
  str_ncpy(cu->rhost, cu->ibuf, sizeof(cu->rhost));
#if 0
  hp = gethostbyaddr(cu->rhost, sizeof(struct in_addr), AF_INET);
  str_ncpy(cu->rhost,
    hp ? hp->h_name : inet_ntoa((struct in_addr *) cu->rhost),
    sizeof(cu->rhost) - 1);
#endif

  cu->userno = utent;

  if (cu->clitype)
    send_to_user(cu, "é †åˆ©", 0, MSG_LOGINOK);
  else
    send_to_user(cu, CHAT_LOGIN_OK, 0, MSG_MESSAGE);

  arrive_room(cu, &mainroom);

  send_to_user(cu, "", 0, MSG_MOTDSTART);
  print_user_counts(cu);
  send_to_user(cu, "", 0, MSG_MOTDEND);

#ifdef  DEBUG
  logit("enter", "OK");
#endif

  return 0;
}


static void
chat_act(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (QUIET(cu->room) && (!(ROOMOP(cu))))
    return;

#ifdef HAVE_KILL_GAME
  if(!kill_can_talk(cu->room,cu))
  {
    send_to_user(cu,"\033[1;35m$$ ä½ ç¾åœ¨åšçš„å‹•ä½œåˆ¥äººçœ‹ä¸åˆ°å“¦\033[m", 
      0, MSG_MESSAGE);
    return;
  }
#endif

  if (*msg)
  {
    char buf[256];

    sprintf(buf, "%s [36m%s[m", cu->chatid, msg);
    send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,cu);
  }
}


static void
chat_ignore(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *str, buf[256];

  if (RESTRICTED(cu))
  {
    str = "â€» æ‚¨æ²’æœ‰ ignore åˆ¥äººçš„æ¬Šåˆ©";
  }
  else
  {
    char *ignoree;

    str = buf;
    ignoree = nextword(&msg);
    if (*ignoree)
    {
      ChatUser *xuser;

      xuser = cuser_by_userid(ignoree);

      if (xuser == NULL)
      {
    sprintf(str, msg_no_such_id, ignoree);
      }
      else if (xuser == cu || CHATSYSOP(xuser) ||
    (ROOMOP(xuser) && (xuser->room == cu->room)))
      {
    sprintf(str, "â—† ä¸å¯ä»¥ ignore [%s]", ignoree);
      }
      else
      {
    if (list_belong(cu->ignore, xuser->userno))
    {
      sprintf(str, "â€» %s å·²ç¶“è¢«å‡çµäº†", xuser->chatid);
    }
    else
    {
      list_add(&(cu->ignore), xuser);
      sprintf(str, "â—† å°‡ [%s] æ‰“å…¥å†·å®®äº† :p", xuser->chatid);
    }
      }
    }
    else
    {
      UserList *list;

      if (list = cu->ignore)
      {
    int len;
    char userid[16];

    send_to_user(cu, "â—† é€™äº›äººè¢«æ‰“å…¥å†·å®®äº†ï¼š", 0, MSG_MESSAGE);
    len = 0;
    do
    {
      sprintf(userid, "%-13s", list->userid);
      strcpy(str + len, userid);
      len += 13;
      if (len >= 78)
      {
        send_to_user(cu, str, 0, MSG_MESSAGE);
        len = 0;
      }
    } while (list = list->next);

    if (len == 0)
      return;
      }
      else
      {
    str = "â—† æ‚¨ç›®å‰å¹¶æ²’æœ‰ ignore ä»»ä½•äºº";
      }
    }
  }

  send_to_user(cu, str, 0, MSG_MESSAGE);
}


static void
chat_unignore(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *ignoree, *str, buf[80];

  ignoree = nextword(&msg);

  if (*ignoree)
  {
    sprintf(str = buf, (list_delete(&(cu->ignore), ignoree)) ?
      "â—† [%s] ä¸å†è¢«ä½ å†·è½äº†" :
      "â—† æ‚¨å¹¶æœª ignore [%s] é€™è™Ÿäººç‰©", ignoree);
  }
  else
  {
    str = "â—† è«‹æŒ‡æ˜ user ID";
  }
  send_to_user(cu, str, 0, MSG_MESSAGE);
}


static void
chat_join(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (RESTRICTED(cu))
  {
    send_to_user(cu, "â€» æ‚¨æ²’æœ‰åŠ å…¥å…¶ä»–èŠå¤©å®¤çš„æ¬Šé™", 0, MSG_MESSAGE);
  }
  else
  {
    char *roomid = nextword(&msg);

    if (*roomid)
      enter_room(cu, roomid, msg, 0);
    else
      send_to_user(cu, "â€» è«‹æŒ‡å®šèŠå¤©å®¤", 0, MSG_MESSAGE);
  }
}

#ifdef HAVE_KILL_GAME
static void
kill_join(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (RESTRICTED(cu))
  {
    send_to_user(cu, "â€» æ‚¨æ²’æœ‰åŠ å…¥å…¶ä»–èŠå¤©å®¤çš„æ¬Šé™", 0, MSG_MESSAGE);
  }
  else
  {
    char *roomid = nextword(&msg);

    if (*roomid)
      enter_room(cu, roomid, msg, ROOM_KILLGAME);
    else
      send_to_user(cu, "â€» è«‹æŒ‡å®šèŠå¤©å®¤", 0, MSG_MESSAGE);
  }
}

#endif

static void
chat_interview(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *twit, buf[80];
  ChatUser *xuser;

  if (!ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  twit = nextword(&msg);
  xuser = cuser_by_chatid(twit);

  if (xuser == NULL)
  {                       /* Thor.980604: ç”¨ useridä¹Ÿå˜›é€š */
    xuser = cuser_by_userid(twit);
  }

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  strcpy(interviewer, twit);
}

static void
chat_kick(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *twit, buf[80];
  ChatUser *xuser;
  ChatRoom *room;

  if (!ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  twit = nextword(&msg);
  xuser = cuser_by_chatid(twit);

  if (xuser == NULL)
  {                       /* Thor.980604: ç”¨ useridä¹Ÿå˜›é€š */
    xuser = cuser_by_userid(twit);
  }

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  room = cu->room;
  if (room != xuser->room || CLOAK(xuser))
  {
    sprintf(buf, msg_not_here, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  if (CHATSYSOP(xuser))
  {
    sprintf(buf, "â—† ä¸å¯ä»¥ kick [%s]", twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  exit_room(xuser, EXIT_KICK, (char *) NULL);

  if (room == &mainroom)
    xuser->uptime = 0;      /* logout_user(xuser); */
  else
    enter_room(xuser, MAIN_NAME, (char *) NULL, 0);
    /* Thor.980602: å…¶å¯¦è¸¢å°±è¸¢,ä¸è¦showå‡ºxxxé›¢é–‹äº†çš„è¨Šæ¯æ¯”è¼ƒå¥½ */
}

static void
chat_makeop(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *newop, buf[80];
  ChatUser *xuser;
  ChatRoom *room;

  /* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— */

  newop = nextword(&msg);

  room = cu->room;

  if(!*newop && CHATSYSOP(cu))
  {
    /* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— */
    cu->uflag ^= PERM_CHATOP;

    user_changed(cu);
    if (!CLOAK(cu))
    {
      sprintf(buf,ROOMOP(cu) ? "â€» çœŸæƒ…ä½¿è€… å°‡ Op æ¬ŠåŠ›æˆäºˆ %s"
                             : "â€» çœŸæƒ…ä½¿è€… å°‡ %s çš„ Op æ¬ŠåŠ›æ”¶å›", cu->chatid);
      send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
    }

    return;
  }

  /* if (!ROOMOP(cu)) */
  /* Thor.980603: chat roomç¸½ç®¡ä¸èƒ½è½‰ç§» Op æ¬ŠåŠ› */
  /* fuse:æˆ‘è©¦è©¦èªª
  if (!(cu->uflag & PERM_ROOMOP))
  */
  if (!ROOMOP(cu))
  {
    send_to_user(cu, "â—† æ‚¨ä¸èƒ½è½‰ç§» Op çš„æ¬ŠåŠ›", 0, MSG_MESSAGE);
    return;
  }

  xuser = cuser_by_chatid(newop);

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, newop);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  if (cu == xuser)
  {
    send_to_user(cu, "â€» æ‚¨æ—©å°±å·²ç¶“æ˜¯ Op äº†å•Š", 0, MSG_MESSAGE);
    return;
  }

  /* room = cu->room; */

  if (room != xuser->room || CLOAK(xuser))
  {
    sprintf(buf, msg_not_here, xuser->chatid);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  /* å…©æ¬¡æˆäºˆOpå–æ¶ˆ */
  if (CHATSYSOP(cu) && (xuser->uflag & PERM_ROOMOP))
  {
     xuser->uflag  &= ~PERM_ROOMOP;
     user_changed(xuser);
     return;
  }

  /* fuseï¼š å¦‚æœæ˜¯chat sysopï¼Œé‚£å°±ä¸æŠŠè‡ªå·±æ¬ŠåŠ›å»æ‰äº† */
  if (!CHATSYSOP(cu))
     cu->uflag &= ~PERM_ROOMOP;
  xuser->uflag |= PERM_ROOMOP;

  user_changed(cu);
  user_changed(xuser);

  if (!CLOAK(cu))
  {
    sprintf(buf, "â€» %s å°‡ Op æ¬ŠåŠ›è½‰ç§»çµ¦ %s",
      cu->chatid, xuser->chatid);
    send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  }
}

#if 0
static void
chat_makeop(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *newop, buf[80];
  ChatUser *xuser;
  ChatRoom *room;

  /* Thor.980603: PERM_CHATROOMæ”¹ç‚º default æ²’æœ‰ roomop, ä½†å¯ä»¥è‡ªå·±å–å¾— */
  if (!ROOMOP(cu))
  /* if (!ROOMOP(cu) && !CHATSYSOP(cu)) */
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  newop = nextword(&msg);
  xuser = cuser_by_chatid(newop);

#if 0
  if (xuser == NULL)
  {                       /* Thor.980604: ç”¨ useridä¹Ÿå˜›é€š */
    xuser = cuser_by_userid(newop);
  }
#endif

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, newop);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  if (cu == xuser)
  {
    send_to_user(cu, "â€» æ‚¨æ—©å°±å·²ç¶“æ˜¯ Op äº†å•Š", 0, MSG_MESSAGE);
    return;
  }

  room = cu->room;

  if (room != xuser->room || CLOAK(xuser))
  {
    sprintf(buf, msg_not_here, xuser->chatid);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  cu->uflag &= ~PERM_ROOMOP;
  xuser->uflag |= PERM_ROOMOP;

  user_changed(cu);
  user_changed(xuser);

  if (!CLOAK(cu))
  {
    sprintf(buf, "â€» %s å°‡ Op æ¬ŠåŠ›è½‰ç§»çµ¦ %s",
      cu->chatid, xuser->chatid);
    send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  }
}

#endif

static void
chat_invite(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char *invitee, buf[80];
  ChatUser *xuser;
  ChatRoom *room;
  UserList **list;

  if (!ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return;
  }

  invitee = nextword(&msg);
  xuser = cuser_by_chatid(invitee);

#if 0
  if (xuser == NULL)
  {                       /* Thor.980604: ç”¨ useridä¹Ÿå˜›é€š */
    xuser = cuser_by_userid(invitee);
  }
#endif

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, invitee);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  room = cu->room;      /* Thor: æ˜¯å¦è¦ check room æ˜¯å¦ NULL ? */
  list = &(room->invite);

  if (list_belong(*list, xuser->userno))
  {
    sprintf(buf, "â€» %s å·²ç¶“æ¥å—éé‚€è«‹äº†", xuser->chatid);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }
  list_add(list, xuser);

  sprintf(buf, "â€» %s é‚€è«‹æ‚¨åˆ° [%s] èŠå¤©å®¤",
    cu->chatid, room->name);
  send_to_user(xuser, buf, 0, MSG_MESSAGE);
  sprintf(buf, "â€» %s æ”¶åˆ°æ‚¨çš„é‚€è«‹äº†", xuser->chatid);
  send_to_user(cu, buf, 0, MSG_MESSAGE);
}


static void
chat_broadcast(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char buf[80];

  if (!CHATSYSOP(cu))
  {
    send_to_user(cu, "â€» æ‚¨æ²’æœ‰åœ¨èŠå¤©å®¤å»£æ’­çš„æ¬ŠåŠ›!", 0, MSG_MESSAGE);
    return;
  }

  if (*msg == '\0')
  {
    send_to_user(cu, "â€» è«‹æŒ‡å®šå»£æ’­å…§å®¹", 0, MSG_MESSAGE);
    return;
  }

  sprintf(buf, "[1mâ€» " BOARDNAME "è«‡å¤©å®¤å»£æ’­ä¸­ [%s].....[m",
    cu->chatid);
  send_to_room(ROOM_ALL, buf, 0, MSG_MESSAGE,NULL);
  sprintf(buf, "â—† %s", msg);
  send_to_room(ROOM_ALL, buf, 0, MSG_MESSAGE,NULL);
}


static void
chat_bye(cu, msg)
  ChatUser *cu;
  char *msg;
{
  exit_room(cu, EXIT_LOGOUT, msg);
  cu->uptime = 0;
  /* logout_user(cu); */
}


/* --------------------------------------------- */
/* MUD-like social commands : action             */
/* --------------------------------------------- */

struct ChatAction
{
  char *verb;           /* å‹•è© */
  char *chinese;        /* ä¸­æ–‡ç¿»è­¯ */
  char *part1_msg;      /* ä»‹è© */
  char *part2_msg;      /* å‹•ä½œ */
};


static ChatAction party_data[] =
{
  {
    "aluba", "é˜¿é­¯å·´", "æŠŠ", "æ¶ä¸ŠæŸ±å­é˜¿é­¯å·´!!"
  },
  {
    "aodre", "æ™¯ä»°", "å°", "çš„æ™¯ä»°æœ‰å¦‚æ»”æ»”æ±Ÿæ°´,é€£ç¶¿ä¸çµ•â€¦â€¦"
  },
  {
    "bearhug", "ç†±æ“", "ç†±æƒ…çš„æ“æŠ±", ""
  },
  {
    "blade", "ä¸€åˆ€", "ä¸€åˆ€å•Ÿç¨‹æŠŠ", "é€ä¸Šè¥¿å¤©"
  },                /* Thor.0729:è§€çœ¾è¦æ±‚ */
  {
    "bless", "ç¥ç¦", "ç¥ç¦", "å¿ƒæƒ³äº‹æˆ"
  },
  {
    "board", "ä¸»æ©Ÿæ¿", "æŠŠ", "æŠ“å»è·ªä¸»æ©Ÿæ¿"
  },                /* Thor.0730: è§€çœ¾è¦æ±‚ */
  {
    "bokan", "æ°£åŠŸ", "é›™æŒå¾®åˆï¼Œè“„å‹¢å¾…ç™¼â€¦â€¦çªç„¶é–“ï¼Œé›»å…‰ä¹ç¾ï¼Œå°", "ä½¿å‡ºäº†ï¼¢o--
ï¼«anï¼"
  },
  {
    "bow", "é èº¬", "ç•¢èº¬ç•¢æ•¬çš„å‘", "é èº¬"
  },
  {
    "box", "å¹•ä¹‹å…§", "é–‹å§‹è¼ªæ“ºå¼ç§»ä½ï¼Œå°", "ä½œè‚è‡Ÿæ”»æ“Š"
  },
  {
    "boy", "å¹³åº•é‹", "å¾èƒŒå¾Œæ‹¿å‡ºäº†å¹³åº•é‹ï¼ŒæŠŠ", "æ•²æ˜äº†"
  },
  {
    "bye", "æ°æ°", "å‘", "èªªæ°æ°!!"
  },
  {
    "call", "å‘¼å–š", "å¤§è²çš„å‘¼å–š,å•Š~~", "å•Š~~~ä½ åœ¨å“ªè£¡å•Šå•Šå•Šå•Š~~~~"
  },
  {
    "caress", "è¼•æ’«", "è¼•è¼•çš„æ’«æ‘¸è‘—", ""
  },
  {
    "clap", "é¼“æŒ", "å‘", "ç†±çƒˆé¼“æŒ"
  },
  {
    "claw", "æŠ“æŠ“", "å¾è²“å’ªæ¨‚åœ’å€Ÿäº†åªè²“çˆªï¼ŒæŠŠ", "æŠ“å¾—æ­»å»æ´»ä¾†"
  },
  {
    "comfort", "å®‰æ…°", "æº«è¨€å®‰æ…°", ""
  },
  {
    "cong", "æ­å–œ", "å¾èƒŒå¾Œæ‹¿å‡ºäº†æ‹‰ç‚®ï¼Œâ–¡ï¼â–¡ï¼æ­å–œ", ""
  },
  {
    "cpr", "å£å°å£", "å°è‘—", "åšå£å°å£äººå·¥å‘¼å¸"
  },
  {
    "cringe", "ä¹æ†", "å‘", "å‘èº¬å±ˆè†ï¼Œæ–å°¾ä¹æ†"
  },
  {
    "cry", "å¤§å“­", "å‘", "åšå••å¤§å“­"
  },
  {
    "dance", "è·³èˆ", "æ‹‰äº†", "çš„æ‰‹ç¿©ç¿©èµ·èˆ"
  },
  {
    "destroy", "æ¯€æ»…", "ç¥­èµ·äº†ã€æ¥µå¤§æ¯€æ»…å’’æ–‡ã€ï¼Œè½Ÿå‘", ""
  },
  {
    "dogleg", "ç‹—è…¿", "å°", "ç‹—è…¿"
  },
  {
    "drivel", "æµå£æ°´", "å°è‘—", "æµå£æ°´"
  },

#if 0
  /* Thor.0729: èˆ‡ //love é‡è¦† */
  {
    "emotion", "å‘Šç™½", "å°", "ç´”æƒ…çš„å‘Šç™½"
  },
#endif

  {
    "envy", "ç¾¨æ…•", "å‘", "æµéœ²å‡ºç¾¨æ…•çš„çœ¼å…‰"
  },
  {
    "eye", "é€ç§‹æ³¢", "å°", "é »é€ç§‹æ³¢"
  },
  {
    "fire", "éŠ¬å•", "æ‹¿è‘—ç«ç´…çš„éµæ£’èµ°å‘", ""
  },
  {
    "forgive", "åŸè«’", "æ¥å—é“æ­‰ï¼ŒåŸè«’äº†", ""
  },
  {
    "french", "æ³•å¼å»", "æŠŠèˆŒé ­ä¼¸åˆ°", "å–‰åš¨è£¡ï½ï½ï½å“‡ï¼ä¸€å€‹æµªæ¼«çš„æ³•åœ‹æ°æ·±å»"
  },
  {
    "giggle", "å‚»ç¬‘", "å°è‘—", "å‚»å‚»çš„å‘†ç¬‘"
  },
  {
    "glue", "è£œå¿ƒ", "ç”¨ä¸‰ç§’è† ï¼ŒæŠŠ", "çš„å¿ƒé»äº†èµ·ä¾†"
  },                /* Thor.0731:æ‡‰è§€çœ¾è¦æ±‚ */
  {
    "goodbye", "å‘Šåˆ¥", "æ·šçœ¼æ±ªæ±ªçš„å‘", "å‘Šåˆ¥"
  },
  {
    "grin", "å¥¸ç¬‘", "å°", "éœ²å‡ºé‚ªæƒ¡çš„ç¬‘å®¹"
  },
  {
    "growl", "å’†å“®", "å°", "å’†å“®ä¸å·²"
  },
  {
    "hand", "æ¡æ‰‹", "è·Ÿ", "æ¡æ‰‹"
  },
  /* {"hide","èº²","ç”¨åŠ›åœ°èº²è‘—",""}, */
  {
    "hide", "èº²", "èº²åœ¨", "èƒŒå¾Œ"
  },                /* Thor.0729: è§€çœ¾ä¿®æ”¹ç‰ˆ */
  {
    "hospitl", "é€é†«é™¢", "æŠŠ", "é€é€²é†«é™¢"
  },
  {
    "hug", "æ“æŠ±", "è¼•è¼•åœ°æ“æŠ±", ""
  },
  {
    "hrk", "â–¡é¾æ‹³", "æ²‰ç©©äº†èº«å½¢ï¼ŒåŒ¯èšäº†å…§å‹ï¼Œå°", "ä½¿å‡ºäº†ä¸€è¨˜ï¼¨o--ï¼²yu--ï¼«anï¼
ï¼ï¼"
  },
  {
    "hypnoze", "å‚¬çœ ", "æ‹¿è‘—æŒ‚è¡¨æ™ƒå‘€æ™ƒçš„ï¼Œå°", "å±•é–‹å‚¬çœ â€¦â€¦"
  },    /* Thor.980619: æ–°è© */
  {
    "jab", "æˆ³äºº", "æº«æŸ”çš„æˆ³è‘—", ""
  },
  {
    "judo", "éè‚©æ‘”", "æŠ“ä½äº†", "çš„è¡£è¥Ÿï¼Œè½‰èº«â€¦â€¦å•Šï¼Œæ˜¯ä¸€è¨˜éè‚©æ‘”ï¼"
  },
  {
    "kickout", "è¸¢", "ç”¨å¤§è…³æŠŠ", "è¸¢åˆ°å±±ä¸‹å»äº†"
  },
  {
    "kick", "è¸¢äºº", "æŠŠ", "è¸¢çš„æ­»å»æ´»ä¾†"
  },
  {
    "kiss", "è¼•å»", "è¼•å»", "çš„è‡‰é °"
  },
  {
    "laugh", "å˜²ç¬‘", "å¤§è²å˜²ç¬‘", ""
  },
  {
    "levis", "çµ¦æˆ‘", "èªªï¼šçµ¦æˆ‘", "ï¼å…¶ä½™å…è«‡ï¼"
  },
  {
    "lick", "èˆ”", "ç‹‚èˆ”", ""
  },
  {
    "lobster", "å£“åˆ¶", "æ–½å±•é€†è¦å½¢å›ºå®šï¼ŒæŠŠ", "å£“åˆ¶åœ¨åœ°æ¿ä¸Š"
  },
  {
    "love", "è¡¨ç™½", "å°", "æ·±æƒ…çš„è¡¨ç™½"
  },
  {
    "marry", "æ±‚å©š", "æ§è‘—ä¹ç™¾ä¹åä¹æœµç«ç‘°å‘", "æ±‚å©š"
  },
  {
    "no", "ä¸è¦å•Š", "æ‹¼å‘½å°è‘—", "æ–é ­~~~~ä¸è¦å•Š~~~~"
  },
  {
    "nod", "é»é ­", "å‘", "é»é ­ç¨±æ˜¯"
  },
  {
    "nudge", "é ‚è‚šå­", "ç”¨æ‰‹è‚˜é ‚", "çš„è‚¥è‚šå­"
  },
  {
    "pad", "æ‹è‚©è†€", "è¼•æ‹", "çš„è‚©è†€"
  },
  {
    "pettish", "æ’’å¬Œ", "è·Ÿ", "å—²è²å—²æ°£åœ°æ’’å¬Œ"
  },
  {
    "pili", "éœ¹é‚", "ä½¿å‡º å›å­é¢¨ å¤©åœ°æ ¹ èˆ¬è‹¥æ‡º ä¸‰å¼åˆä¸€æ‰“å‘", "~~~~~~"
  },
  /* Thor.0729: æ‡‰è§€çœ¾è¦æ±‚ */
  {
    "pinch", "æ“°äºº", "ç”¨åŠ›çš„æŠŠ", "æ“°çš„é»‘é’"
  },
  {
    "roll", "æ‰“æ»¾", "æ”¾å‡ºå¤šçˆ¾è¢çš„éŸ³æ¨‚,", "åœ¨åœ°ä¸Šæ»¾ä¾†æ»¾å»"
  },
  {
    "protect", "ä¿è­·", "ä¿è­·è‘—", ""
  },
  {
    "pull", "æ‹‰", "æ­»å‘½åœ°æ‹‰ä½", "ä¸æ”¾"
  },
  {
    "punch", "æäºº", "ç‹ ç‹ æäº†", "ä¸€é “"
  },
  {
    "rascal", "è€è³´", "è·Ÿ", "è€è³´"
  },
  {
    "recline", "å…¥æ‡·", "é‘½åˆ°", "çš„æ‡·è£¡ç¡è‘—äº†â€¦â€¦"
  },
  {
    "respond", "è² è²¬", "å®‰æ…°", "èªªï¼šã€ä¸è¦å“­ï¼Œæˆ‘æœƒè² è²¬çš„â€¦â€¦ã€"
  },
  {
    "shrug", "è³è‚©", "ç„¡å¥ˆåœ°å‘", "è³äº†è³è‚©è†€"
  },
  {
    "sigh", "å˜†æ°£", "å°", "å˜†äº†ä¸€å£æ°£"
  },
  {
    "slap", "æ‰“è€³å…‰", "å•ªå•ªçš„å·´äº†", "ä¸€é “è€³å…‰"
  },
  {
    "smooch", "æ“å»", "æ“å»è‘—", ""
  },
  {
    "snicker", "ç«Šç¬‘", "å˜¿å˜¿å˜¿..çš„å°", "ç«Šç¬‘"
  },
  {
    "sniff", "ä¸å±‘", "å°", "å—¤ä¹‹ä»¥é¼»"
  },

  {
    "spank", "æ‰“å±å±", "ç”¨å·´æŒæ‰“", "çš„è‡€éƒ¨"
  },
  /* {"spank", "ç”¨è²“çˆªæŠ“", "çš„è‡€éƒ¨","æŠ“è‡€éƒ¨"}, */
  {
    "squeeze", "ç·Šæ“", "ç·Šç·Šåœ°æ“æŠ±è‘—", ""
  },
  {
    "sysop", "å¬å–š", "å«å‡ºäº†è¸¢ç±³ç†Šï¼ŒæŠŠ", "è¸©æ‰äº†ï¼"
  },
  {
    "thank", "æ„Ÿè¬", "å‘", "æ„Ÿè¬å¾—äº”é«”æŠ•åœ°"
  },
  {
    "tickle", "æ”ç—’", "å’•å˜°!å’•å˜°!æ”", "çš„ç—’"
  },
  {
    "wake", "æ–é†’", "è¼•è¼•åœ°æŠŠ", "æ–é†’"
  },
  {
    "wave", "æ®æ‰‹", "å°è‘—", "æ‹¼å‘½çš„æ–æ‰‹"
  },
  {
    "welcome", "æ­¡è¿", "æ­¡è¿", "é€²ä¾†å…«å¦ä¸€ä¸‹"
  },
  {
    "what", "ä»€éº¼", "èªªï¼šã€", "å“©å…¬çå¯†å“‡éš´è½æŸ?ï¼Ÿ?â–¡?ã€"
  },
  {
    "whip", "é­å­", "æ‰‹ä¸Šæ‹¿è‘—è Ÿç‡­ï¼Œç”¨é­å­ç—›æ‰“", ""
  },
  {
    "wink", "çœ¨çœ¼", "å°", "ç¥ç§˜çš„çœ¨çœ¨çœ¼ç›"
  },
  {
    "zap", "çŒ›æ”»", "å°", "ç˜‹ç‹‚çš„æ”»æ“Š"
  },
/* lkchu.981201: add by mat */
  {
    "1", "ï¼‘è™Ÿ", "æ‹¿å‡ºé›»é‹¸ï¼Œæœ", "é‹¸äº†ä¸‹å»..."
  },
  {
    "2", "ï¼’è™Ÿ", "å°", "é–‹æ§ï¼"
  },
  {
    "3", "ï¼“è™Ÿ", "ç¢°äº†ä¸€è²ï¼Œ", "å•Š~~äº†ä¸€è²ï¼"
  },
  {
    "4", "ï¼”è™Ÿ", "æŒºèµ·æ©Ÿæ§ï¼ŒæŠŠ", "æ‰“æˆèœ‚çª©"
  },
  {
    "5", "ï¼•è™Ÿ", "é§•è‘—å¡è»Šï¼Œç„¶å¾Œçªç„¶å°", "å³è½‰..."
  },
  {
    "6", "ï¼–è™Ÿ", "bon quey äº†ï¼æ‹¿èµ·å…­è™Ÿæ²–å‘", ""
  },
  {
    "7", "ï¼—è™Ÿ", "å°", "æ‹‹äº†ä¸€å€‹åªšçœ¼ï¼ŒæŠŠä»–çœ‹æ­»äº†..."
  },
  {
    "8", "ï¼˜è™Ÿ", "æŒ‰äº† pauseï¼Œç„¶å¾Œé–‹å§‹å°", "ç ´å£å¤§ç½µ"
  },
  {
    "bite", "å’¬", "æŠŠ", "å’¬å¾—æ­»å»æ´»ä¾†"
  },
  {
    "bfydown", "é˜²å¾¡é™", "æ–½å±•å’’èª", "é˜²å¾¡åŠ›ä¸‹é™äº†..."
  },
  {
    "bfyup", "é˜²å¾¡å‡","æ–½å±•å’’èª", "é˜²å¾¡åŠ›ä¸Šå‡äº†..."
  },
  {
    "clock", "åˆ‡é¬§é˜", "åˆ‡æ‰", "çš„é¬§é˜..."
  },
  {
    "cola", "çŒå¯æ¨‚", "å°", "çŒäº†ä¸€æ¡¶å¯æ¨‚"
  },
  {
    "cowhide", "é­æ‰“","æ‹¿é­å­å°", "ç‹ ç‹ åœ°æŠ½æ‰“"
  },
  {
    "crime", "é“å¾·", "èªª:", "çš„é“å¾·æŒ‡æ•¸ä¸å¤ "
  },
  {
    "evening", "æ™šå®‰", "å°", "èªªã€æ™šå®‰ã€"
  },
  {
    "fireball", "ç™¼ç«çƒ", "å°", "ç™¼äº†ä¸€é¡†ç«çƒ"
  },
  {
    "hpup", "hpä¸Šå‡", "æ–½å±•å’’èª", "ç”Ÿå‘½åŠ›ä¸Šå‡è‡³æ¥µé™"
  },
  {
    "kissbye", "å»åˆ¥", "è·Ÿ", "å»åˆ¥..."
  },
  {
    "mail", "æ‰“åŒ…", "æŠŠ", "æ‰“åŒ…éé€åˆ°ç™¾æ…•å¤§"
  },
  {
    "morning", "æ—©å®‰", "å°", "èªªã€æ—©å®‰ã€"
  },
  {
    "noon", "åˆå®‰", "å°", "èªªã€åˆå®‰ã€"
  },
  {
    "puding", "çŒå¸ƒä¸", "å°", "çŒäº†ä¸€å¡è»Šå¸ƒä¸"
  },
  {
    "recycle", "å›æ”¶æ¡¶", "æŠŠ", "ä¸Ÿåˆ°è³‡æºå›æ”¶æ¡¶"
  },
  {
    "sex", "é¨·æ“¾", "å°", "é¨·æ“¾"
  },
  {
    "shit", "é›ªç‰¹", "å°", "ç½µäº†ä¸€è² é›ªç‰¹"
  },
  {
    "wait", "ç­‰ä¸€ä¸‹", "å«", "ç­‰ä¸€ä¸‹å“¦!"
  },
  {
    "wall", "ä»–æ’ç‰†", "æŠ“è‘—", "çš„é ­å¾€ç‰†ç”¨åŠ›æ’äº†å‡ ä¸‹"
  },
  {
    "blink", "å§”æ›²æ·š", "å°è‘—", "çœ¨çœ¨çœ¼,æ‰ä¸‹äº†å§”æ›²çš„çœ¼æ·šã€‚"
  },
  {
    "book", "ä¸Ÿæ›¸", "æ‹¿äº†ä¸€æœ¬æ›¸æœ", "é‚£ä¸Ÿäº†éå»"
  },
  {
    "crash", "å¡ŠçŸ³é ­", "ä½¿å‹åœ°èˆ‰èµ·å¤§çŸ³é ­å¾€", "èº«ä¸Šä¸Ÿå»"
  },
  {
    "curtsey", "ä¸­å¤ç¦®", "å„ªé›…åœ°å°è‘—","è¡Œä¸­å¤ä¸–ç´€çš„å±ˆè†ç¦®ã€‚"
  },
  {
    "fuzzy","é£›é³¥","æ´¾å‡ºé£›é³¥ä¸€è™Ÿå‘","æ²–éå»"
  },
  {
    "gag","ç¸«å˜´å·´","æŠŠ","çš„å˜´å·´ç”¨é‡ç¸«èµ·ä¾†"
  },
  {
    "glare", "çªäºº", "å†·å†·åœ°çªè‘—",""
  },
  {
    "kill", "ç äºº", "æŠŠ", "äº‚åˆ€ç æ­»~~~~"
  },
  {
    "listen", "è½", "å«", "é–‰å˜´ä»”ç´°è½"
  },
  {
    "mglint", "èª¿çš®", "çœ¼ç›å°è‘—", "é–ƒå‹•è‘—ä¸€é™£èª¿çš®çš„å…‰èŠ’"
  },
  {
    "pat", "æ‹é ­", "æ‹æ‹", "çš„é ­"
  },
  {
    "pettish", "æ’’å¬Œ", "è·Ÿ", "å—²è²å—²æ°£åœ°æ’’å¬Œ"
  },
  {
    "scratch", "ç£¨çˆª", "æ’¿èµ·", "èº«é‚Šçš„çŸ³å­ç£¨ç£¨è‡ªå·±çš„åˆ©çˆª"
  },
  {
    "sorry", "å°ä¸èµ·", "å‘", "èªªå°ä¸èµ·! æˆ‘éŒ¯äº†!"
  },
  {
    "wiggle", "æ‰­å±è‚¡", "å°è‘—", "æ‰­å±è‚¡"
  },

  {
    NULL, NULL, NULL, NULL
  }
};


static int
party_action(cu, cmd, party)
  ChatUser *cu;
  char *cmd;
  char *party;
{
  ChatAction *cap;
  char *verb, buf[256];

  for (cap = party_data; verb = cap->verb; cap++)
  {
    if (str_equal(verb, cmd))
    {
      if (*party == '\0')
      {
    party = "å¤§å®¶";
      }
      else
      {
    ChatUser *xuser;

    xuser = fuzzy_cuser_by_chatid(party);
    if (xuser == NULL)
    {           /* Thor.0724: ç”¨ useridä¹Ÿå˜›é€š */
      xuser = cuser_by_userid(party);
    }

    if (xuser == NULL)
    {
      sprintf(buf, msg_no_such_id, party);
      send_to_user(cu, buf, 0, MSG_MESSAGE);
      return 0;
    }
    else if (xuser == FUZZY_USER)
    {
      send_to_user(cu, "â€» è«‹æŒ‡æ˜èŠå¤©ä»£è™Ÿ", 0, MSG_MESSAGE);
      return 0;
    }
    else if (cu->room != xuser->room || CLOAK(xuser))
    {
      sprintf(buf, msg_not_here, party);
      send_to_user(cu, buf, 0, MSG_MESSAGE);
      return 0;
    }
    else
    {
      party = xuser->chatid;
    }
      }
      sprintf(buf, "[1;32m%s [31m%s[33m %s [31m%s[m",
    cu->chatid, cap->part1_msg, party, cap->part2_msg);
      send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,cu);
      return 0;         /* Thor: cu->room æ˜¯å¦ç‚º NULL? */
    }
  }
  return 1;
}


/* --------------------------------------------- */
/* MUD-like social commands : speak              */
/* --------------------------------------------- */


static ChatAction speak_data[] =
{
  {
    "ask", "è©¢å•", "å•", NULL
  },
  {
    "chant", "æ­Œé Œ", "é«˜è²æ­Œé Œ", NULL
  },
  {
    "cheer", "å–é‡‡", "å–é‡‡", NULL
  },
  {
    "chuckle", "è¼•ç¬‘", "è¼•ç¬‘", NULL
  },
  {
    "curse", "æš—å¹¹", "æš—å¹¹", NULL
  },
  /* {"curse", "å’’ç½µ", NULL}, */
  {
    "demand", "è¦æ±‚", "è¦æ±‚", NULL
  },
  {
    "frown", "çšºçœ‰é ­", "è¹™çœ‰", NULL
  },
  {
    "groan", "å‘»åŸ", "å‘»åŸ", NULL
  },
  {
    "grumble", "ç™¼ç‰¢é¨·", "ç™¼ç‰¢é¨·", NULL
  },
  {
    "guitar", "å½ˆå”±", "é‚Šå½ˆè‘—å‰ä»–ï¼Œé‚Šå”±è‘—", NULL
  },
  /* {"helpme", "å‘¼æ•‘","å¤§è²å‘¼æ•‘",NULL}, */
  {
    "hum", "å–ƒå–ƒ", "å–ƒå–ƒè‡ªèª", NULL
  },
  {
    "moan", "æ€¨å˜†", "æ€¨å˜†", NULL
  },
  {
    "notice", "å¼·èª¿", "å¼·èª¿", NULL
  },
  {
    "order", "å‘½ä»¤", "å‘½ä»¤", NULL
  },
  {
    "ponder", "æ²ˆæ€", "æ²ˆæ€", NULL
  },
  {
    "pout", "å™˜å˜´", "å™˜è‘—å˜´èªª", NULL
  },
  {
    "pray", "ç¥ˆç¦±", "ç¥ˆç¦±", NULL
  },
  {
    "request", "æ‡‡æ±‚", "æ‡‡æ±‚", NULL
  },
  {
    "shout", "å¤§ç½µ", "å¤§ç½µ", NULL
  },
  {
    "sing", "å”±æ­Œ", "å”±æ­Œ", NULL
  },
  {
    "smile", "å¾®ç¬‘", "å¾®ç¬‘", NULL
  },
  {
    "smirk", "å‡ç¬‘", "å‡ç¬‘", NULL
  },
  {
    "swear", "ç™¼èª“", "ç™¼èª“", NULL
  },
  {
    "tease", "å˜²ç¬‘", "å˜²ç¬‘", NULL
  },
#if 0
  {
    "titter", "å·ç¬‘", "å·ç¬‘", NULL
  }, /* Thor.980619: æ–°è© */
#endif
  {
    "whimper", "å—šå’½", "å—šå’½çš„èªª", NULL
  },
  {
    "yawn", "å“ˆæ¬ ", "é‚Šæ‰“å“ˆæ¬ é‚Šèªª", NULL
  },
  {
    "yell", "å¤§å–Š", "å¤§å–Š", NULL
  },
  {
    NULL, NULL, NULL, NULL
  }
};


static int
speak_action(cu, cmd, msg)
  ChatUser *cu;
  char *cmd;
  char *msg;
{
  ChatAction *cap;
  char *verb, buf[256];

  for (cap = speak_data; verb = cap->verb; cap++)
  {
    if (str_equal(verb, cmd))
    {
      sprintf(buf, "[1;32m%s [31m%sï¼š[33m %s[m",
    cu->chatid, cap->part1_msg, msg);
      send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,cu);
      return 0;
    }
  }
  return 1;
}


/* ----------------------------------------------------- */
/* MUD-like social commands : condition          */
/* ----------------------------------------------------- */


static ChatAction condition_data[] =
{
  {
    "applaud", "æ‹æ‰‹", "å•ªå•ªå•ªå•ªå•ªå•ªå•ª....", NULL
  },
  {
    "ayo", "å”‰å‘¦å–‚", "å”‰å‘¦å–‚~~~", NULL
  },
  {
    "back", "åå›ä¾†", "å›ä¾†åæ­£ç¹¼çºŒå¥®æˆ°", NULL
  },
  {
    "blood", "åœ¨è¡€ä¸­", "å€’åœ¨è¡€æ³Šä¹‹ä¸­", NULL
  },
  {
    "blush", "è‡‰ç´…", "è‡‰éƒ½ç´…äº†", NULL
  },
  {
    "broke", "å¿ƒç¢", "çš„å¿ƒç ´ç¢æˆä¸€ç‰‡ä¸€ç‰‡çš„", NULL
  },                /* Thor.0731:æ‡‰è§€çœ¾è¦æ±‚ */
  /* {"bokan", "Bo Kan! Bo Kan!", NULL}, */
  {
    "careles", "æ²’äººç†", "å—šï½ï½éƒ½æ²’æœ‰äººç†æˆ‘ :~~~~", NULL
  },
  {
    "chew", "å—‘ç“œå­", "å¾ˆæ‚ é–‘çš„å—‘èµ·ç“œå­ä¾†äº†", NULL
  },
  {
    "climb", "çˆ¬å±±", "è‡ªå·±æ…¢æ…¢çˆ¬ä¸Šå±±ä¾†â€¦â€¦", NULL
  },
  {
    "cold", "æ„Ÿå†’äº†", "æ„Ÿå†’äº†,åª½åª½ä¸è®“æˆ‘å‡ºå»ç© :~~~(", NULL
  },
  {
    "cough", "å’³å—½", "å’³äº†å‡ è²", NULL
  },
  {
    "die", "æš´æ–ƒ", "ç•¶å ´æš´æ–ƒ", NULL
  },
  {
    "faint", "æ˜å€’", "ç•¶å ´æ˜å€’", NULL
  },
  {
    "flop", "é¦™è•‰çš®", "è¸©åˆ°é¦™è•‰çš®... æ»‘å€’ï¼", NULL
  },
  {
    "fly", "é£„é£„ç„¶", "é£„é£„ç„¶", NULL
  },
  {
    "frown", "è¹™çœ‰", "è¹™çœ‰", NULL
  },
  {
    "gold", "æ‹¿é‡‘ç‰Œ", "å”±è‘—ï¼šã€é‡‘ã„ã„ â–¡é‡‘ã„ã„ â–¡  å‡ºåœ‹æ¯”è³½! å¾—å† è»ï¼Œæ‹¿é‡‘ç‰Œï¼ã€",
 NULL
  },
  {
    "gulu", "è‚šå­é¤“", "çš„è‚šå­ç™¼å‡ºå’•åš•~~~å’•åš•~~~çš„è²éŸ³", NULL
  },
  {
    "haha", "å“‡å“ˆå“ˆ", "å“‡å“ˆå“ˆå“ˆ.....^o^", NULL
  },
  /* {"haha", "å¤§ç¬‘","å“‡å“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆ~~~~!!!!!", NULL}, */
  {
    "helpme", "æ±‚æ•‘", "å¤§å–Š~~~æ•‘å‘½å•Š~~~~", NULL
  },
  {
    "hoho", "å‘µå‘µç¬‘", "å‘µå‘µå‘µç¬‘å€‹ä¸åœ", NULL
  },
  {
    "happy", "é«˜èˆˆ", "é«˜èˆˆå¾—åœ¨åœ°ä¸Šæ‰“æ»¾", NULL
  },
  /* {"happy", "é«˜èˆˆ", "ï¼¹ï¼¡ï¼ *^_^*", NULL}, */
  /* {"happy", "", "r-o-O-m....è½äº†çœŸçˆ½ï¼", NULL}, */
  /* {"hurricane", "ï¼¨ï½---ï¼²ï½™ï½•--ï¼«ï½ï½ï¼ï¼ï¼", NULL}, */
  {
    "hypnzed", "è¢«å‚¬çœ ", "çœ¼ç¥å‘†æ»¯ï¼Œè¢«å‚¬çœ äº†â€¦â€¦ï½šï¼ºï½šzzz", NULL
  },  /* Thor.980619: æ–°è© */
  {
    "idle", "å‘†ä½äº†", "å‘†ä½äº†", NULL
  },
  {
    "jacky", "æ™ƒæ™ƒ", "ç—å­èˆ¬çš„æ™ƒä¾†æ™ƒå»", NULL
  },

#if 0
  /* Thor.0729: ä¸çŸ¥å…¶æ„ */
  {
    "lag", "ç¶²è·¯æ…¢", "lllllllaaaaaaaaaaaagggggggggggggg.................", NULL
  },
#endif

  {
    "luck", "å¹¸é‹", "å“‡ï¼ç¦æ°£å•¦ï¼", NULL
  },
  {
    "macarn", "ä¸€ç¨®èˆ", "é–‹å§‹è·³èµ·äº†ï¼­aï¼£aï¼²eï¼®aï½ï½ï½ï½", NULL
  },
  {
    "miou", "å–µå–µ", "å–µå–µå£è‹—å£è‹—ï½ï½ï½ï½ï½", NULL
  },
  {
    "mouth", "æ‰å˜´", "æ‰å˜´ä¸­!!", NULL
  },
  {
    "nani", "æ€éº¼æœƒ", "ï¼šå¥ˆã„å•Šæ??", NULL
  },
  {
    "nose", "æµé¼»è¡€", "æµé¼»è¡€", NULL
  },
  {
    "puke", "å˜”å", "å˜”åä¸­", NULL
  },
  /* {"puke", "çœŸæƒ¡å¿ƒï¼Œæˆ‘è½äº†éƒ½æƒ³å", NULL}, */
  {
    "rest", "ä¼‘æ¯", "ä¼‘æ¯ä¸­ï¼Œè«‹å‹¿æ‰“æ“¾", NULL
  },
  {
    "reverse", "ç¿»è‚š", "ç¿»è‚š", NULL
  },
  {
    "room", "é–‹æˆ¿é–“", "r-o-O-m-r-O-ï¼¯-Mmm-rRï¼²........", NULL
  },
  {
    "shake", "æ–é ­", "æ–äº†æ–é ­", NULL
  },
  {
    "sleep", "ç¡è‘—", "è¶´åœ¨éµç›¤ä¸Šç¡è‘—äº†ï¼Œå£æ°´æµé€²éµç›¤ï¼Œé€ æˆç•¶æ©Ÿï¼", NULL
  },
  {
    "so", "å°±é†¬å­", "å°±é†¬å­!!", NULL
  },
  {
    "sorry", "é“æ­‰", "å—šå•Š!!æˆ‘å°ä¸èµ·å¤§å®¶,æˆ‘å°ä¸èµ·åœ‹å®¶ç¤¾æœƒ~~~~~~å—šå•Š~~~~~", NULL
  },
  {
    "story", "è¬›å¤", "é–‹å§‹è¬›å¤äº†", NULL
  },
  {
    "strut", "æ–æ“ºèµ°", "å¤§æ–å¤§æ“ºåœ°èµ°", NULL
  },
  {
    "suicide", "è‡ªæ®º", "è‡ªæ®º", NULL
  },
  {
    "tea", "æ³¡èŒ¶", "æ³¡äº†å£ºå¥½èŒ¶", NULL
  },
  {
    "think", "æ€è€ƒ", "æ­ªè‘—é ­æƒ³äº†ä¸€ä¸‹", NULL
  },
  {
    "tongue", "åèˆŒ", "åäº†åèˆŒé ­", NULL
  },
  {
    "wall", "æ’ç‰†", "è·‘å»æ’ç‰†", NULL
  },
  {
    "wawa", "å“‡å“‡", "å“‡å“‡å“‡~~~~~!!!!!  ~~~>_<~~~", NULL
  },
  {
    "www", "æ±ªæ±ª", "æ±ªæ±ªæ±ª!!!", NULL
  },
  {
    "zzz", "æ‰“å‘¼", "å‘¼åš•~~~~ZZzZzï½šï¼ºZZzzZzzzZZ...", NULL
  },
  /* lkchu.981201: add by mat */
  {
    "agree", "åŒæ„", "æ·±è¡¨åŒæ„", NULL
  },
  {
    "ah", "éˆå…‰", "è‹¦æ€è‰¯ä¹…ï¼Œå¿½ç„¶éˆå…‰ä¸€ç¾ï¼Œä¸ç¦å‘€çš„ä¸€è²ã€‚", NULL
  },
  {
    "ak", "æ’è…°", "åˆæ°£åˆç„¡å¥ˆçš„å…©æ‰‹æ’è…°", NULL
  },
  {
    "avert", "å®³ç¾", "å®³ç¾åœ°è½‰é–‹è¦–ç·š", NULL
  },
  {
    "dive", "è³ºéŒ¢", "åŸ‹é¦–ç ”ç©¶æ€æ¨£è³ºå¤§éŒ¢ã€‚", NULL
  },
  {
    "hiccup", "æ‰“å—", "æ‰“å—ä¸­", NULL
  },
  {
    "jealous", "åƒé†‹", "æ°£é¼“é¼“åœ°å–äº†ä¸€ç¼¸é†‹", NULL
  },
  {
    "jump", "è·³æ¨“", "è·³æ¨“è‡ªæ®º", NULL
  },
  {
    "mutter", "ä½å’•", "ä½è²å’•å™¥è‘—æŸäº›äº‹ã€‚", NULL
  },
  {
    "scream", "å°–å«", "å¤§è²å°–å«!! å•Š~~~~~~~", NULL
  },
  {
    "snore", "æ‰“é¼¾ä¸­", "æ‰“é¼¾ä¸­...", NULL
  },
  {
    "stare", "å‡è¦–", "éœéœåœ°å‡è¦–è‘—å¤©ç©º", NULL
  },
  {
    "stretch", "ç–²å€¦", "ä¼¸ä¼¸æ‡¶è…°åˆæ‰“äº†å€‹å‘µæ¬ å¾ˆç–²å€¦ä¼¼çš„ã€‚", NULL
  },
  {
    "sweat", "æµæ±—", "æ®æ±—å¦‚é›¨ï¼ï¼", NULL
  },
  {
    "tear", "æµæ·š", "ç—›å“­æµæ¶•ä¸­.....", NULL
  },
  {
    "wc", "æ´—æ‰‹é–“", "ä¼æ´—æ‰‹é–“ä¸€ä¸‹ :>", NULL
  },
  {
    "whine", "è‚šå­é¤“", "è‚šå­é¤“! :(", NULL
  },
  {
    "whistle", "å¹å£å“¨", "å¹å£å“¨", NULL
  },
  {
    "ya", "ã„›è€¶", "å™¢ï½ï¼¹ï¼¡ï¼ *^_^*", NULL
  },

  {
    NULL, NULL, NULL, NULL
  }
};


static int
condition_action(cu, cmd)
  ChatUser *cu;
  char *cmd;
{
  ChatAction *cap;
  char *verb, buf[256];

  for (cap = condition_data; verb = cap->verb; cap++)
  {
    if (str_equal(verb, cmd))
    {
      sprintf(buf, "[1;32m%s [31m%s[m",
    cu->chatid, cap->part1_msg);
      send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,cu);
      return 1;
    }
  }
  return 0;
}


/* --------------------------------------------- */
/* MUD-like social commands : help               */
/* --------------------------------------------- */


static char *dscrb[] =
{
  "[1;37mã€ Verb + Nickï¼š   å‹•è© + å°æ–¹åå­— ã€‘[36m  ä¾‹ï¼š//kick piggy[m",
  "[1;37mã€ Verb + Messageï¼šå‹•è© + è¦èªªçš„è©± ã€‘[36m  ä¾‹ï¼š//sing å¤©å¤©å¤©è—[m",
  "[1;37mã€ Verbï¼šå‹•è© ã€‘   â†‘â†“ï¼šèˆŠè©±é‡æ[m", NULL
};



static ChatAction *catbl[] =
{
  party_data, speak_data, condition_data, NULL
};


static void
chat_partyinfo(cu, msg)
  ChatUser *cu;
  char *msg;
{
  if (common_client_command)
  {
    send_to_user(cu, "3 å‹•ä½œ  äº¤è«‡  ç‹€æ…‹", 0, MSG_PARTYINFO);
  }
}


static void
chat_party(cu, msg)
  ChatUser *cu;
  char *msg;
{
  int kind, i;
  ChatAction *cap;
  char buf[80];

  if (!common_client_command)
    return;

  kind = atoi(nextword(&msg));
  if (kind < 0 || kind > 2)
    return;

  sprintf(buf, "%d\t%s", kind, kind == 2 ? "I" : "");

  /* Xshadow: åªæœ‰ condition æ‰æ˜¯ immediate mode */
  send_to_user(cu, buf, 0, MSG_PARTYLISTSTART);

  cap = catbl[kind];
  for (i = 0; cap[i].verb; i++)
  {
    sprintf(buf, "%-10s %-20s", cap[i].verb, cap[i].chinese);
    send_to_user(cu, buf, 0, MSG_PARTYLIST);
  }

  sprintf(buf, "%d", kind);
  send_to_user(cu, buf, 0, MSG_PARTYLISTEND);
}


#define SCREEN_WIDTH    80
#define MAX_VERB_LEN    8
#define VERB_NO     10


static void
view_action_verb(cu, cmd)   /* Thor.0726: æ–°åŠ å‹•è©åˆ†é¡é¡¯ç¤º */
  ChatUser *cu;
  int cmd;
{
  int i;
  char *p, *q, *data, *expn, buf[256];
  ChatAction *cap;

  send_to_user(cu, "/c", 0, MSG_CLRSCR);

  data = buf;

  if (cmd < '1' || cmd > '3')
  {             /* Thor.0726: å¯«å¾—ä¸å¥½, æƒ³è¾¦æ³•æ”¹é€²... */
    for (i = 0; p = dscrb[i]; i++)
    {
      sprintf(data, "  [//]help %d          - MUD-like ç¤¾äº¤å‹•è©   ç¬¬ %d é¡", i
+ 1, i + 1);
      send_to_user(cu, data, 0, MSG_MESSAGE);
      send_to_user(cu, p, 0, MSG_MESSAGE);
      send_to_user(cu, " ", 0, MSG_MESSAGE);    /* Thor.0726: æ›è¡Œ */
    }
  }
  else
  {
    i = cmd - '1';

    send_to_user(cu, dscrb[i], 0, MSG_MESSAGE);

    expn = buf + 100;       /* Thor.0726: æ‡‰è©²ä¸æœƒoverlapå§? */

    *data = '\0';
    *expn = '\0';

    cap = catbl[i];

    for (i = 0; p = cap[i].verb; i++)
    {
      q = cap[i].chinese;

      strcat(data, p);
      strcat(expn, q);

      if (((i + 1) % VERB_NO) == 0)
      {
    send_to_user(cu, data, 0, MSG_MESSAGE);
    send_to_user(cu, expn, 0, MSG_MESSAGE); /* Thor.0726: é¡¯ç¤ºä¸­æ–‡æ³¨è§£ */
    *data = '\0';
    *expn = '\0';
      }
      else
      {
    strncat(data, "        ", MAX_VERB_LEN - strlen(p));
    strncat(expn, "        ", MAX_VERB_LEN - strlen(q));
      }
    }

    if (i % VERB_NO)
    {
      send_to_user(cu, data, 0, MSG_MESSAGE);
      send_to_user(cu, expn, 0, MSG_MESSAGE);   /* Thor.0726: é¡¯ç¤ºä¸­æ–‡æ³¨è§£ */
    }
  }
  /* send_to_user(cu, " ",0); *//* Thor.0726: æ›è¡Œ, éœ€è¦ " " å—? */
}


/* ----------------------------------------------------- */
/* chat user service routines                            */
/* ----------------------------------------------------- */


static ChatCmd chatcmdlist[] =
{
  "act", chat_act, 0,
  "bye", chat_bye, 0,
  "chatroom", chat_chatroom, 1, /* Xshadow: for common client */
  "clear", chat_clear, 0,
  "cloak", chat_cloak, 2,
  "date", chat_date, 0,
  "flags", chat_setroom, 0,
  "help", chat_help, 0,
  "ignore", chat_ignore, 1,
  "invite", chat_invite, 0,
  "join", chat_join, 0,
#ifdef HAVE_KILL_GAME // esp: must follow the 'join' or this will be matched to
 '/j'
  "jkill",kill_join, 0,
  "kstart",kill_start,0,
  "kend",kill_end,0,
  "kill",kill_kill,1,
  "kover",kill_over,0,
  "kquery",kill_police_query,0,
  "kkk",kill_kkk,1,
  "kstate",kill_show_state,1,
  // "kvote",kill_vote,1,
  // "kkile",kill_user_vote,0,
  // "kclearvote",kill_clear_vote,0,
  // "kday",kill_sunrise,1,
  // "knight",kill_sunset,1,
#endif
  "kick", chat_kick, 1,
  "msg", chat_private, 0,
  "nick", chat_nick, 0,
  "operator", chat_makeop, 0,
  "party", chat_party, 1,   /* Xshadow: party data for common client */
  "partyinfo", chat_partyinfo, 1,   /* Xshadow: party info for common
                     * client */

#ifndef STAND_ALONE
  "query", chat_query, 0,
#endif

  "room", chat_list_rooms, 0,
  "unignore", chat_unignore, 1,
  "whoin", chat_list_by_room, 1,
  "wall", chat_broadcast, 2,
  /* fuse.991211 */
  "interview", chat_interview, 2,

  "who", chat_map_chatids_thisroom, 0,
  "list", chat_list_users, 0,
  "topic", chat_topic, 1,
  "to", chat_towards, 1,
  "version", chat_version, 1,

  NULL, NULL, 0
};


/* Thor: 0 ä¸ç”¨ exact, 1 è¦ exactly equal, 2 ç§˜å¯†æŒ‡ä»¤ */


static int
command_execute(cu)
  ChatUser *cu;
{
  char *cmd, *msg, buf[128];
  /* Thor.981108: lkchu patch: chatid + msg åªç”¨ 80 bytes ä¸å¤ , æ”¹ç‚º 128 */
  ChatCmd *cmdrec;
  int match, ch;

  msg = cu->ibuf;
  match = *msg;

  /* Validation routine */

  if (cu->room == NULL)
  {
    /* MUST give special /! or /-! command if not in the room yet */

    if (match == '/' && ((ch = msg[1]) == '!' || (ch == '-' && msg[2] == '!')))
    {
      if (ch == '-')
    fprintf(flog, "cli\t[%d] S%d\n", cu->sno, cu->sock);

      cu->clitype = (ch == '-') ? 1 : 0;
      return (login_user(cu, msg + 2 + cu->clitype));
    }
    else
    {
      return -1;
    }
  }

  /* If not a /-command, it goes to the room. */

  if (match != '/')
  {
    if (match)
    {
      /* fuse.991210: INTERVIEWæ¨¡å¼åªæœ‰opå¯ä»¥èªªè©± */
      if (INTERVIEW(cu->room) && (!(ROOMOP(cu))))
         return 0;

      if (cu->room && !CLOAK(cu))   /* éš±èº«çš„äººä¹Ÿä¸èƒ½èªªè©±å“¦ */
      {
        char chatid[16];

        sprintf(chatid, "%s:", cu->chatid);
#ifdef HAVE_KILL_GAME
        if (cu->room->rflag & ROOM_KILL_STARTED && 
          cu->room->currenttalker == cu)
          sprintf(buf, "%-10s\033[1;32m%s\033[0m", chatid, msg);
        else
          sprintf(buf, "%-10s%s", chatid, msg);
#else
        sprintf(buf, "%-10s%s", chatid, msg);
#endif
        send_to_room(cu->room, buf, cu->userno, MSG_MESSAGE,cu);
      }
    }
    return 0;
  }

  msg++;
  cmd = nextword(&msg);
  match = 0;

  if (*cmd == '/')
  {
    cmd++;
    if (!*cmd || str_equal("help", cmd))
    {
      cmd = nextword(&msg); /* Thor.0726: å‹•è©åˆ†é¡ */
      view_action_verb(cu, *cmd);
      match = 1;
    }
    else
    {
     /* fuse.991210: QUIETæ¨¡å¼ä¸‹ä¸ä½œå‹•ä½œäº† */
     if (!QUIET(cu->room)) {
      if (party_action(cu, cmd, msg) == 0)
        match = 1;
      else if (speak_action(cu, cmd, msg) == 0)
        match = 1;
      else
        match = condition_action(cu, cmd);
     }
    }
  }
  else
  {
    char *str;

    common_client_command = 0;
    if (*cmd == '-')
    {
      if (cu->clitype)
      {
    cmd++;          /* Xshadow: æŒ‡ä»¤å¾ä¸‹ä¸€å€‹å­—å…ƒæ‰é–‹å§‹ */
    common_client_command = 1;
      }
      else
      {
    /* ä¸æ˜¯ common client ä½†é€å‡º common client æŒ‡ä»¤ -> å‡è£æ²’çœ‹åˆ° */
      }
    }

    str_lower(buf, cmd);

    for (cmdrec = chatcmdlist; str = cmdrec->cmdstr; cmdrec++)
    {
      switch (cmdrec->exact)
      {
      case 1:           /* exactly equal */
    match = str_equal(str, buf);
    break;

      case 2:           /* Thor: secret command */
    if (CHATSYSOP(cu))
      match = str_equal(str, buf);
    break;

      default:          /* not necessary equal */
    match = str_match(buf, str) >= 0;
    break;
      }

      if (match)
      {
    cmdrec->cmdfunc(cu, msg);
    break;
      }
    }
  }

  if (!match)
  {
    sprintf(buf, "â—† æŒ‡ä»¤éŒ¯èª¤ï¼š/%s", cmd);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }

  return 0;
}


/* ----------------------------------------------------- */
/* serve chat_user's connection                          */
/* ----------------------------------------------------- */


static int
cuser_serve(cu)
  ChatUser *cu;
{
  int ch, len, isize;
  char *str, *cmd, buf[256];

  str = buf;
  len = recv(cu->sock, str, sizeof(buf) - 1, 0);
  if (len < 0)
  {
#ifdef HAVE_KILL_GAME
    if(0 /* cu->room->rflag & ROOM_KILL_STARTED */)
    {
      if(cu->killflag & KILL_DROPED)
      {
        if(time(0) - cu->uptime > 5 * 60) // esp: 5 minutes
        {
          ch = errno;

          exit_room(cu, EXIT_KICK, NULL);
          logit("recv", sys_errlist[ch]);
          return -1;
        }
        else
          return 1;
      }
      else
      {
         // esp: hold this user
         exit_room(cu,EXIT_LOSTCONN,NULL);
         return 1;

      }
    }
    else
    {
      ch = errno;

      exit_room(cu, EXIT_LOSTCONN, NULL);
      logit("recv", sys_errlist[ch]);
      return -1;
    }
#else
    ch = errno;

    exit_room(cu, EXIT_LOSTCONN, NULL);
    logit("recv", sys_errlist[ch]);
    return -1;
#endif

#if 0
    if (ch != EWOULDBLOCK)
    {
      exit_room(cu, EXIT_LOSTCONN, NULL);
      logit("recv", sys_errlist[ch]);
      return -1;
    }

    return 0;           /* would block, so leave it to do later */
#endif
  }

  if (len == 0)
  {
    if (++cu->retry > 100)
      return -1;
    return 0;
  }

#if 0
  /* Xshadow: å°‡é€é”çš„è³‡æ–™å¿ å¯¦ç´€éŒ„ä¸‹ä¾† */
  memcpy(logbuf, buf, sizeof(buf));
  for (ch = 0; ch < sizeof(buf); ch++)
    if (!logbuf[ch])
      logbuf[ch] = '$';

  logbuf[len + 1] = '\0';
  logit("recv: ", logbuf);
#endif

#if 0
  logit(cu->userid, str);
#endif

  cu->xdata += len;

  isize = cu->isize;
  cmd = cu->ibuf + isize;
  while (len--)
  {
    ch = *str++;

    if (ch == '\r' || !ch)
      continue;

    if (ch == '\n')
    {
      *cmd = '\0';

      if (command_execute(cu) < 0)
    return -1;

      isize = 0;
      cmd = cu->ibuf;

      continue;
    }

    if (isize < 79)
    {
      *cmd++ = ch;
      isize++;
    }
  }
  cu->isize = isize;
  return 1;
}


/* ----------------------------------------------------- */
/* chatroom server core routines                         */
/* ----------------------------------------------------- */


static int
/* start_daemon(mode)
  int mode; */
servo_daemon(inetd)
  int inetd;
{
  int fd, value;
  char buf[80];
  struct sockaddr_in sin;
  struct linger ld;
  struct rlimit limit;

  /*
   * More idiot speed-hacking --- the first time conversion makes the C
   * library open the files containing the locale definition and time zone.
   * If this hasn't happened in the parent process, it happens in the
   * children, once per connection --- and it does add up.
   */

  time((time_t *) &value);
  gmtime((time_t *) &value);
  strftime(buf, 80, "%d/%b/%Y:%H:%M:%S", localtime((time_t *) &value));

  /* --------------------------------------------------- */
  /* speed-hacking DNS resolve                           */
  /* --------------------------------------------------- */

  dns_init();
#if 0
  gethostname(buf, sizeof(buf));
  gethostbyname(buf);
#endif

  /* --------------------------------------------------- */
  /* adjust the resource limit                           */
  /* --------------------------------------------------- */

  getrlimit(RLIMIT_NOFILE, &limit);
  limit.rlim_cur = limit.rlim_max;
  setrlimit(RLIMIT_NOFILE, &limit);

  limit.rlim_cur = limit.rlim_max = 4 * 1024 * 1024;
  setrlimit(RLIMIT_DATA, &limit);

#ifdef SOLARIS
#define RLIMIT_RSS RLIMIT_AS
  /* Thor.981206: port for solaris 2.6 */
#endif

  setrlimit(RLIMIT_RSS, &limit);

  limit.rlim_cur = limit.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &limit);

#if 0
  limit.rlim_cur = limit.rlim_max = 60 * 20;
  setrlimit(RLIMIT_CPU, &limit);
#endif

  /* --------------------------------------------------- */
  /* detach daemon process                               */
  /* --------------------------------------------------- */

  close(2);
  close(1);

  /* if (mode > 1) */
  if(inetd)
    return 0;

  close(0);

  if (fork())
    exit(0);

  setsid();

  if (fork())
    exit(0);

  /* --------------------------------------------------- */
  /* bind the service port               */
  /* --------------------------------------------------- */

  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  /*
   * timeout æ–¹é¢, å°‡ socket æ”¹æˆ O_NDELAY (no delay, non-blocking),
   * å¦‚æœèƒ½é †åˆ©é€å‡ºè³‡æ–™å°±é€å‡º, ä¸èƒ½é€å‡ºå°±ç®—äº†, ä¸å†ç­‰å¾… TCP_TIMEOUT æ™‚é–“ã€‚
   * (default æ˜¯ 120 ç§’, å¹¶ä¸”æœ‰ 3-way handshaking æ©Ÿåˆ¶, æœ‰å¯èƒ½ä¸€ç­‰å†ç­‰)ã€‚
   */

#if 1
  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NDELAY);
#endif

  value = 1;
  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &value, sizeof(value));

  value = 1;
  setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &value, sizeof(value));

  ld.l_onoff = ld.l_linger = 0;
  setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld));

  sin.sin_family = AF_INET;
  sin.sin_port = htons(CHAT_PORT);
  sin.sin_addr.s_addr = htonl(INADDR_ANY);
  memset(sin.sin_zero, 0, sizeof(sin.sin_zero));

  if ((bind(fd, (struct sockaddr *) & sin, sizeof(sin)) < 0) ||
    (listen(fd, SOCK_QLEN) < 0))
    exit(1);

  return fd;
}


#ifdef  SERVER_USAGE
static void
server_usage()
{
  struct rusage ru;

  if (getrusage(RUSAGE_SELF, &ru))
    return;

  fprintf(flog, "\n[Server Usage]\n\n"
    "user time: %.6f\n"
    "system time: %.6f\n"
    "maximum resident set size: %lu P\n"
    "integral resident set size: %lu\n"
    "page faults not requiring physical I/O: %d\n"
    "page faults requiring physical I/O: %d\n"
    "swaps: %d\n"
    "block input operations: %d\n"
    "block output operations: %d\n"
    "messages sent: %d\n"
    "messages received: %d\n"
    "signals received: %d\n"
    "voluntary context switches: %d\n"
    "involuntary context switches: %d\n"
    "gline: %d\n\n",

    (double) ru.ru_utime.tv_sec + (double) ru.ru_utime.tv_usec / 1000000.0,
    (double) ru.ru_stime.tv_sec + (double) ru.ru_stime.tv_usec / 1000000.0,
    ru.ru_maxrss,
    ru.ru_idrss,
    ru.ru_minflt,
    ru.ru_majflt,
    ru.ru_nswap,
    ru.ru_inblock,
    ru.ru_oublock,
    ru.ru_msgsnd,
    ru.ru_msgrcv,
    ru.ru_nsignals,
    ru.ru_nvcsw,
    ru.ru_nivcsw,
    gline);

  fflush(flog);
}
#endif


static void
reaper()
{
  while (waitpid(-1, NULL, WNOHANG | WUNTRACED) > 0)
    ;
}


static void
sig_trap(sig)
  int sig;
{
  char buf[80];

  sprintf(buf, "signal [%d] at line %d (errno: %d)", sig, gline, errno);
  logit("EXIT", buf);
  fclose(flog);
  exit(1);
}


static void
sig_over()
{
  int fd;

  server_usage();
  logit("OVER", "");
  fclose(flog);
  for (fd = 0; fd < 64; fd++)
    close(fd);
  execl("bin/xchatd", NULL);
}


static void
main_signals()
{
  struct sigaction act;

  /* sigblock(sigmask(SIGPIPE)); */
  /* Thor.981206: çµ±ä¸€ POSIX æ¨™å‡†ç”¨æ³•  */

  /* act.sa_mask = 0; */ /* Thor.981105: æ¨™å‡†ç”¨æ³• */
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;

  act.sa_handler = sig_trap;
  sigaction(SIGBUS, &act, NULL);
  sigaction(SIGSEGV, &act, NULL);
  sigaction(SIGTERM, &act, NULL);

  act.sa_handler = sig_over;
  sigaction(SIGXCPU, &act, NULL);

  act.sa_handler = reaper;
  sigaction(SIGCHLD, &act, NULL);

#ifdef  SERVER_USAGE
  act.sa_handler = server_usage;
  sigaction(SIGPROF, &act, NULL);
#endif

  /* Thor.981206: lkchu patch: çµ±ä¸€ POSIX æ¨™å‡†ç”¨æ³•  */
  /* åœ¨æ­¤å€Ÿç”¨ sigset_t act.sa_mask */
  sigaddset(&act.sa_mask, SIGPIPE);
  sigprocmask(SIG_BLOCK, &act.sa_mask, NULL);

}


int
main(argc, argv)
  int argc;
  char *argv[];
{
  int sock, nfds, maxfds, servo_sno;
  ChatUser *cu,/* *userpool,*/ **FBI;
  time_t uptime, tcheck;
  fd_set rset, xset;
  static struct timeval tv = {CHAT_INTERVAL, 0};
  struct timeval tv_tmp; /* Thor.981206: for future reservation bug */

  sock = 0;

  while ((nfds = getopt(argc, argv, "hid")) != -1)
  {
    switch (nfds)
    {
    case 'i':
      sock = 1;
      break;

    case 'd':
      break;

    case 'h':
    default:

      fprintf(stderr, "Usage: %s [options]\n"
        "\t-i  start from inetd with wait option\n"
        "\t-d  debug mode\n"
        "\t-h  help\n",
        argv[0]);
      exit(0);
    }
  }

  servo_daemon(sock);
  /* start_daemon(argc); */

  setgid(BBSGID);
  setuid(BBSUID);
  chdir(BBSHOME);
  umask(077);

  log_init();

  main_signals();

  /* --------------------------------------------------- */
  /* init variable : rooms & users           */
  /* --------------------------------------------------- */

  userpool = NULL;
  strcpy(mainroom.name, MAIN_NAME);
  strcpy(mainroom.topic, MAIN_TOPIC);

  /* --------------------------------------------------- */
  /* main loop                       */
  /* --------------------------------------------------- */

  tcheck = 0;
  servo_sno = 0;

  for (;;)
  {
    uptime = time(0);
    if (tcheck < uptime)
    {
      nfds = maxfds = 0;
      FD_ZERO(&mainfset);
      FD_SET(0, &mainfset);

      tcheck = uptime - CHAT_INTERVAL;

      for (FBI = &mainuser; cu = *FBI;)
      {
    if (cu->uptime < tcheck)
    {
      cuser_free(cu);

      *FBI = cu->unext;

      cu->unext = userpool;
      userpool = cu;
    }
    else
    {
      nfds++;
      sock = cu->sock;
      FD_SET(sock, &mainfset);
      if (maxfds < sock)
        maxfds = sock;

      FBI = &(cu->unext);
    }
      }

      totaluser = nfds;
      fprintf(flog, "MAINTAIN %d user (%d)\n", nfds, maxfds++);
      fflush(flog);

      tcheck = uptime + CHAT_INTERVAL;
    }

    /* ------------------------------------------------- */
    /* Set up the fdsets                 */
    /* ------------------------------------------------- */

    rset = mainfset;
    xset = mainfset;

    /* Thor.981206: for future reservation bug */
    tv_tmp = tv;
    nfds = select(maxfds, &rset, NULL, &xset, &tv_tmp);

#if 0
    {
      char buf[32];
      static int xxx;

      if ((++xxx & 8191) == 0)
      {
    sprintf(buf, "%d/%d", nfds, maxfds);
    logit("MAIN", buf);
      }
    }
#endif

    if (nfds == 0)
    {
      continue;
    }

    if (nfds < 0)
    {
      sock = errno;
      if (sock != EINTR)
      {
    logit("select", sys_errlist[sock]);
      }
      continue;
    }

    /* ------------------------------------------------- */
    /* serve active agents               */
    /* ------------------------------------------------- */

    uptime = time(0);

    for (FBI = &mainuser; cu = *FBI;)
    {
      sock = cu->sock;

      if (FD_ISSET(sock, &rset))
      {
    static int xxx, xno;

    nfds = cuser_serve(cu);

    if ((++xxx & 511) == 0)
    {
      int sno;

      sno = cu->sno;
      fprintf(flog, "rset\t[%d] S%d R%d %d\n", sno, sock, nfds, xxx);
      if (sno == xno)
        nfds = -1;
      else
        xno = sno;
    }
      }
      else if (FD_ISSET(sock, &xset))
      {
    nfds = -1;
      }
      else
      {
    nfds = 0;
      }

      if (nfds < 0 || cu->uptime <= 0)  /* free this client */
      {
    cuser_free(cu);

    *FBI = cu->unext;

    cu->unext = userpool;
    userpool = cu;

    continue;
      }

      if (nfds > 0)
      {
    cu->uptime = uptime;
      }

      FBI = &(cu->unext);
    }

    /* ------------------------------------------------- */
    /* accept new connection                 */
    /* ------------------------------------------------- */

    if (FD_ISSET(0, &rset))
    {

      {
    static int yyy;

    if ((++yyy & 2047) == 0)
      fprintf(flog, "conn\t%d\n", yyy);
      }

      for (;;)
      {
    int value;
    struct sockaddr_in sin;

    value = sizeof(sin);
    sock = accept(0, (struct sockaddr *) &sin, &value);
    if (sock > 0)
    {
      if (cu = userpool)
      {
        userpool = cu->unext;
      }
      else
      {
        cu = (ChatUser *) malloc(sizeof(ChatUser));
      }

      *FBI = cu;

      /* variable initialization */

      memset(cu, 0, sizeof(ChatUser));
      cu->sock = sock;
      cu->tbegin = uptime;
      cu->uptime = uptime;
      cu->sno = ++servo_sno;
      cu->xdata = 0;
      cu->retry = 0;
      memcpy(cu->rhost, &sin.sin_addr, sizeof(struct in_addr));

      totaluser++;

      FD_SET(sock, &mainfset);
      if (sock >= maxfds)
        maxfds = sock + 1;

      {
        int value;

        value = 1;
        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
          (char *) &value, sizeof(value));
      }

#if 1
      fcntl(sock, F_SETFL, fcntl(sock, F_GETFL, 0) | O_NDELAY);
#endif

      fprintf(flog, "CONN\t[%d] %d %s\n",
        servo_sno, sock, str_time(&cu->tbegin));
      break;
    }

    nfds = errno;
    if (nfds != EINTR)
    {
      logit("accept", sys_errlist[nfds]);
      break;
    }

#if 0
    while (waitpid(-1, NULL, WNOHANG | WUNTRACED) > 0);
#endif
      }
    }

    /* ------------------------------------------------- */
    /* tail of main loop                 */
    /* ------------------------------------------------- */

  }
}

#ifdef HAVE_KILL_GAME

static void kill_clear_user_vote(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return ;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    user->votenum = 0;

  }
}

static void kill_enable_police_query(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return ;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    if(KILL_ROLE(user) == KILL_POLICE)
      user->killflag &= ~KILL_QUERYED;
  }
}
static void kill_enable_user_talk(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return ;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    user->killflag &= ~KILL_TALKED;
  }
}

static void kill_enable_user_vote(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return ;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    user->killflag &= ~KILL_VOTED;

  }
}

#if 0

static void kill_clear_vote(cu,msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room;

  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹",0,MSG_MESSAGE);
    return;
  }

  if(KILL_ROLE(cu) != KILL_JUDGE)
  {
    send_to_user(cu,"$$ ä½ ä¸æ˜¯æ³•å®˜ï¼Œä¸èƒ½æ¸…é™¤æŠ•ç¥¨è¨˜éŒ„",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus != KILL_AFTERDAY)
  {
    send_to_user(cu,"$$ ç¾åœ¨æ²’æœ‰é€²è¡ŒæŠ•ç¥¨",0,MSG_MESSAGE);
    return;
  }

  kill_clear_user_vote(room);
  kill_enable_user_vote(room);

  kill_refresh_table(room);

  send_to_room(room,"$$ ç¾åœ¨å¤§å®¶é‡æ–°æŠ•ç¥¨å§",0,MSG_MESSAGE,cu);

}

#endif

static void kill_clear_user_state(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return ;

  room->currenttalker = NULL;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    user->killflag = 0;
    user->killstate = 0;
    user->votenum = 0;

  }

  return ;
}

static ChatUser* kill_find_just_killed(room)
  ChatRoom *room;
{
  ChatUser *user;
  if(!room)
    return NULL;

  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(user->killflag & KILL_KILLED && !(user->killflag & KILL_KNOCKOUT))
      return user;

  }

  return NULL;
}

static int chat_get_user_number(room)
  ChatRoom *room;
{
  ChatUser *user;
  int count = 0;
  if(!room)
    return 0;

  /* esp: no cloak , to prevent cheating */
  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    count ++;

  }

  return count;
}

static ChatUser *chat_get_nth_user(room, nth)
  ChatRoom *room;
  int nth;
{
  ChatUser *user;
  int count = 0;
  if(!room)
    return NULL;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    count ++;
    if(count == nth)
      break;
  }

  return user;
}

static int kill_get_user_state(whichroom, cu, user)
  ChatRoom *whichroom;
  ChatUser *cu;
  ChatUser *user;
{
  ChatRoom *room;
  room = cu->room;
  if(room != whichroom)
    return KILL_USER_UNKNOWN;


  if(!(room->rflag & ROOM_KILL_STARTED))
    return KILL_USER_UNKNOWN;

  if(cu == user)
    return user->killstate;

  if(KILL_ROLE(cu) == KILL_KILLER)
  {
    if(KILL_ROLE(user) == KILL_KILLER)
      return user->killstate;
  }
/* esp: å¤§å®¶è¦ºå¾—è­¦å¯Ÿå¤ªå¼·å¤§äº† */

  else if(KILL_ROLE(cu) == KILL_POLICE
    && room->rflag & ROOM_KILL_STRPOLICE
    && user->killflag & KILL_QUERYED
    && !(cu->killflag & KILL_KILLED))
  {
      return user->killstate;
  }

/* esp: zk åˆèªªäº†ï¼Œæ®ºæ‰‹éš±è—å¾—å¾ˆæ·±â€¦â€¦ */
/*
  else if(KILL_ROLE(cu) == KILL_NORMAL)
  {
    if(user->killstate == KILL_USER_KILLED_KILLER
      && user->killflag & KILL_KNOCKOUT)
      return user->killstate;
  }
*/

  if(room->killstatus == KILL_DAY_MURDERED || room->killstatus == KILL_DAY_TALK
    || room->killstatus == KILL_DAY_VOTE || room->killstatus == KILL_AFTERDAY)
    if(user->killflag & KILL_KILLED && !(user->killflag & KILL_KNOCKOUT))
      return KILL_USER_JUSTKILLED;



  if(user->killflag & KILL_KNOCKOUT)
    return KILL_USER_JUSTKILLED;

  return KILL_USER_UNKNOWN;
}

static int kill_can_talk(room,user)
  ChatRoom *room;
  ChatUser *user;
{
  /* esp: return 1 means ok, 0 means can't */

  if(!(room->rflag & ROOM_KILLGAME))
    return 1;

  if(!(room->rflag & ROOM_KILL_STARTED))
    return 1;

  if(room->rflag & ROOM_KILL_WAITDROP)
    return 1;

  if(user->killflag & KILL_KNOCKOUT
    && !(room->rflag & ROOM_KILL_NOGHOST))
    return 1;

  if(room->killstatus == KILL_DAY_TALK
    && room->rflag & ROOM_KILL_DISCUSS)
    return 1; // esp : for argue..;)

  if(room->currenttalker == NULL)
    return 1;

  if(room->killstatus == KILL_DAY_TALK
     || room->killstatus == KILL_BEFORENIGHT)
  {
    if(room->currenttalker == user)
      return 1;
    else
      return 0;
  }
  return 1;
}

static int kill_can_talk_between(room, user1, user2)
  ChatRoom *room;
  ChatUser *user1;
  ChatUser *user2;
{
  /* esp: return 1 means ok, 0 means can't */

  /* What's more. this function only detect if user1 can send
     message to user2, doesn't care about user2 to user1 */

  int rc = 0;
  kill_talk_time_check(room);
  kill_vote_time_check(room);

  if(!(room->rflag & ROOM_KILLGAME))
    return 1;

  if(!(room->rflag & ROOM_KILL_STARTED))
    return 1;

  if(room->rflag & ROOM_KILL_WAITDROP)
    return 1;

  if(user1->killflag & KILL_KNOCKOUT
    && !(room->rflag & ROOM_KILL_NOGHOST))
    return 1;

  switch(room->killstatus)
  {
  case KILL_NIGHT_KILLER:
    if((KILL_ROLE(user1) == KILL_KILLER)
      && KILL_ROLE(user2) == KILL_KILLER)
      rc = 1;
    break;
  case KILL_NIGHT_POLICE:
    if((KILL_ROLE(user1) == KILL_POLICE)
      && KILL_ROLE(user2) == KILL_POLICE)
      rc = 1;
    break;
  case KILL_DAY_MURDERED:
    if(user1->killflag & KILL_KILLED && !(user1->killflag & KILL_KNOCKOUT)
      && room->currenttalker == user1)
      rc = 1;
    break;
  case KILL_DAY_TALK:
    if(
      (!(user1->killflag & KILL_KILLED) && room->currenttalker == user1)
      || room->rflag & ROOM_KILL_DISCUSS)
      rc = 1;
    else
      rc = 0;
    break;
  case KILL_DAY_VOTE:
    rc = 0;
    break;
  case KILL_AFTERDAY:
    if(room->currenttalker == user1)
      rc = 1;
    else
      rc = 0;
    break;
  case KILL_BEFORENIGHT:
    if(user1->killflag & KILL_KILLED && !(user1->killflag & KILL_KNOCKOUT))
      rc = 1;

    break;
  }

  return rc;


}

static void kill_random_role(room)
  ChatRoom *room;
{
  /* esp: the number of roles should be indicated now,
     we random them to guys step by step now.
     judge, police, killer, the left are normal guys.
  */

  int count,countnow;
  int i,r;
  ChatUser *user;
  char buf[200];

  countnow = count = chat_get_user_number(room);
  if(count == 0)
    return;

  srand(time(NULL));

  /* policemen */
  for(i = 0;i<room->policenum;i++)
  {
    r = (float) rand() / RAND_MAX * countnow;
    do
    {
      user = chat_get_nth_user(room,r+1);
      r = (r + 1) % count;
    }while(KILL_ROLE(user) != KILL_NONE);
    // esp: don't allow police query at the beginning
    user->killflag = KILL_POLICE | KILL_QUERYED;
    user->killstate = KILL_USER_POLICE;
    sprintf(buf,"\033[1;33m$$                   æ‚¨çš„è§’è‰²æ˜¯\033[0m %s%s%s ",
      userkillstatecolors[user->killstate],userkillstates[user->killstate],
      "\033[0m");
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);
    send_to_user(user,buf,0,MSG_MESSAGE,NULL);
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);
    countnow --;
  }

  /* killers */
  for(i = 0;i<room->killernum;i++)
  {
    r = (float) rand() / RAND_MAX * countnow;
    do
    {
      user = chat_get_nth_user(room,r+1);
      r = (r + 1) % count;
    }while(KILL_ROLE(user) != KILL_NONE);
    user->killflag = KILL_KILLER;
    user->killstate = KILL_USER_KILLER;
    sprintf(buf,"\033[1;33m$$                   æ‚¨çš„è§’è‰²æ˜¯\033[0m %s%s%s ",
      userkillstatecolors[user->killstate],userkillstates[user->killstate],
      "\033[0m");
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);
    send_to_user(user,buf,0,MSG_MESSAGE,NULL);
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);
    countnow --;
  }

  /* normal guys */
  for(i = 0;i<countnow;i++)
  {
    r = i;
    do
    {
      user = chat_get_nth_user(room,r+1);
      r = (r + 1) % count;
    }while(KILL_ROLE(user) != KILL_NONE);
    user->killflag = KILL_NORMAL;
    user->killstate = KILL_USER_NORMAL;
    sprintf(buf,"\033[1;33m$$                   æ‚¨çš„è§’è‰²æ˜¯\033[0m %s%s%s ",
      userkillstatecolors[user->killstate],userkillstates[user->killstate],
      "\033[0m");
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);
    send_to_user(user,buf,0,MSG_MESSAGE,NULL);
    send_to_user(user,"\033[1;33m$$\033[0m",0,MSG_MESSAGE,NULL);

  }

  return;
}

/* esp: return 1 means game done, 0 means not done */
static int kill_is_finished(room)
  ChatRoom* room;
{
  int killernum = 0,policenum = 0,normalnum = 0;
  ChatUser *user;
  int rc = 0;

  if(!room)
    return 0;

  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(user->killflag & KILL_KILLED)
    {
    if(KILL_ROLE(user)==KILL_POLICE)
      policenum ++;
    else if(KILL_ROLE(user)==KILL_KILLER)
      killernum ++;
    else if(KILL_ROLE(user)==KILL_NORMAL)
      normalnum ++;
    }
  }


  if((room->policenum - policenum) + (room->normalnum - normalnum) <= room->kil
lernum - killernum)
  {
    send_to_room(room,"\033[1;31m$$ $$ \033[5mæ®ºæ‰‹å€‘å·²ç¶“å æ“šäº†å¤šæ•¸ï¼Œæ®ºæ‰‹å€‘å‹åˆ©äº†
ã€‚\033[0m \033[1;31m$$ $$\033[0m",0,MSG_MESSAGE,NULL);
    rc = 1;
  }
  else if(killernum == room->killernum)
  {
    send_to_room(room,"\033[1;32m$$ $$ \033[5m æ®ºæ‰‹å…¨éƒ¨æŠ“ç²ï¼Œè­¦å¯Ÿèˆ‡å¹³æ°‘å‹åˆ©äº†ã€‚
\033[0m \033[1;32m$$ $$\033[0m",0,MSG_MESSAGE,NULL);
    rc = 2;
  }

  if(rc != 0)
  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(KILL_ROLE(user) == KILL_KILLER)
    {
       if(rc == 1)
         kill_log_state(user,1);
       else if(rc == 2)
         kill_log_state(user,2);
    }
    else
    {
       if(rc == 1)
         kill_log_state(user,2);
       else if(rc == 2)
         kill_log_state(user,1);
    }

  }

  return  rc;


}

static void kill_next_status(room, cu)
  ChatRoom* room;
  ChatUser* cu;
{

  ChatUser *user;
  char buf[80];

  if(kill_is_finished(room))
  {
    room->killstatus = KILL_NOT_START;
    send_to_room(room,"\033[1;33m$$$$$$ é€™ä¸€è¼ªéŠæˆ²çµæŸäº† $$$$$$\033[0m",0,MSG_M
ESSAGE,NULL);
    kill_refresh_table(room);
    room->rflag &= ~ROOM_KILL_STARTED;
    kill_clear_user_state(room);

    return;

  }


  kill_clear_user_vote(room);
  kill_enable_user_talk(room);
  kill_enable_user_vote(room);

  room->currenttalker = NULL;

  switch(room->killstatus)
  {
  case KILL_NOT_START:

    room->killstatus = KILL_NIGHT_KILLER;
    room->tvotebegin = time(0);
    send_to_room(room,"\033[1;33m$$         ç¾åœ¨é»‘å¤œé–‹å§‹äº†ï¼Œæ®ºæ‰‹è«‹æŠ•ç¥¨æ®ºäººå§(/k
ill <user>)\033[0m",0,MSG_MESSAGE,NULL);
    break;
  case KILL_NIGHT_KILLER:
    room->killstatus = KILL_NIGHT_POLICE;
    if(room->rflag & ROOM_KILL_STRPOLICE)
      kill_show_next_killer(room);
    else
      kill_enable_police_query(room);
    if(room->policenum > 0)
      send_to_room(room,"\033[1;33m$$         ç¾åœ¨æ®ºæ‰‹æ¶ˆå¤±äº†ï¼Œè­¦å¯Ÿå€‘å‡ºä¾†äº†,ä»–å€‘
ç™¼ç¾äº†æ®ºæ‰‹\033[0m",0,MSG_MESSAGE,NULL);
    // kill_refresh_table(room);
    // break;  // esp: è­¦å¯Ÿéœ€è¦æŸ¥è©¢æ‰çŸ¥é“æ®ºæ‰‹æ˜¯èª°ã€‚
  case KILL_NIGHT_POLICE:
    room->killstatus = KILL_DAY_MURDERED;
    send_to_room(room,"\033[1;33m$$         å¤©äº®äº†ï¼Œå¤§å®¶çš„çœ¼ç›éƒ½çœé–‹äº†\033[0m",
0,MSG_MESSAGE,NULL);
    user = kill_find_just_killed(room);
    if(user)
    {
      sprintf(buf,"\033[1;33m$$         å¾ˆä¸å¹¸ï¼Œ %s è¢«æš—æ®ºäº†\033[0m",user->chat
id);
      send_to_room(room,buf,0,MSG_MESSAGE,NULL);
      room->currenttalker = user;
      user->tkillbegin = time(0);
    }
    send_to_room(room,"\033[1;33m$$         ç¾åœ¨è«‹è½è¢«å®³äººç™¼è¨€ï¼ŒçµæŸç™¼è¨€è«‹ç”¨/ko
\033[0m",0,MSG_MESSAGE,NULL);
    break;
  case KILL_DAY_MURDERED:
    user = kill_find_just_killed(room);
    if(user)
    {
      user->killflag |= KILL_KNOCKOUT;
    }
    room->killstatus = KILL_DAY_TALK;
    send_to_room(room,"\033[1;33m$$         ç¾åœ¨å¤§å®¶è¼ªæµç™¼è¨€ï¼Œç™¼è¡¨è‡ªå·±çš„çœ‹æ³•\03
3[0m",0,MSG_MESSAGE,NULL);

    user = kill_get_next_user(room,NULL);

    if(user)
    {
      room->currenttalker = user;
      user->tkillbegin = time(0);
      sprintf(buf,"\033[1;33m$$         ç¾åœ¨ç”± %s ç™¼è¨€ï¼ŒçµæŸè«‹ç”¨/ko\033[0m",use
r->chatid);
      send_to_room(room,buf,0,MSG_MESSAGE,NULL);
    }
    break;
  case KILL_DAY_TALK:
    room->killstatus = KILL_DAY_VOTE;
    room->tvotebegin = time(0);
    send_to_room(room,"\033[1;33m$$         ç¾åœ¨é–‹å§‹æŠ•ç¥¨ï¼Œä½ çš„æ±ºå®šå°‡æ±ºå®šä¸€å€‹äººçš„
ç”Ÿæ­»(/kill <user>)\033[0m",0,MSG_MESSAGE,NULL);
    break;
  case KILL_DAY_VOTE:
  case KILL_AFTERDAY:
    user = kill_find_just_killed(room);
    if(user)
    {
#if 0 // esp: zk told me that either killer or other should have the chance to
speak
      if(KILL_ROLE(user) == KILL_KILLER)
      {
        sprintf(buf,"\033[1;33m$$         æ®ºæ‰‹ %s è¢«æŠ“ç²äº†ï¼\033[0m",user->chat
id);
        send_to_room(room, buf, 0, MSG_MESSAGE, NULL);
        user->killflag |= KILL_KNOCKOUT;
        room->killstatus = KILL_NOT_START;
        kill_next_status(room,cu);
      }
      else
#endif
      {
        sprintf(buf,"\033[1;33m$$         %s è¢«æ®ºå®³äº†ï¼\033[0m",user->chatid);
        send_to_room(room, buf, 0, MSG_MESSAGE, NULL);
        send_to_room(room, "\033[1;33m$$         è®“æˆ‘å€‘ä¾†è½è½ä»–æœ‰ä»€éº¼è©±è¦èªª\033
[0m", 0, MSG_MESSAGE, NULL);
        room->killstatus = KILL_BEFORENIGHT;
        room->currenttalker = user;
        user->tkillbegin = time(0);
        kill_refresh_table(room);

      }
    }
    break;
  case KILL_BEFORENIGHT:
    user = kill_find_just_killed(room);
    if(user)
    {
      user->killflag |= KILL_KNOCKOUT;
    }
    room->killstatus = KILL_NIGHT_KILLER;
    send_to_room(room,"\033[1;33m$$         ç¾åœ¨é»‘å¤œé–‹å§‹äº†ï¼Œæ®ºæ‰‹è«‹æŠ•ç¥¨æ®ºäººå§(/k
ill <user>)\033[0m",0,MSG_MESSAGE,NULL);

    break;

  }

  kill_refresh_table(room);
  return;
}

static void kill_start(cu, msg)
  ChatUser* cu;
  char* msg;
{
  int count;
  char buf[128];
  ChatRoom *room = cu->room;

  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"â€» å°ä¸èµ·ï¼Œé€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return ;
  }

  if(!ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return ;
  }

  if(room->rflag & ROOM_KILL_STARTED)
  {
    send_to_user(cu, "â€» éŠæˆ²å·²ç¶“é–‹å§‹äº†",0,MSG_MESSAGE);
    return ;
  }

  count = chat_get_user_number(room);

  if(count < 7)
  {
    send_to_user(cu,"â€» å°ä¸èµ·ï¼Œé€™å€‹æˆ¿é–“è£¡çš„äººå¤ªå°‘äº†ï¼Œè‡³å°‘è¦7å€‹äºº",0,MSG_MESSAG
E);
    return ;
  }

  if(count > 15)
  {
    send_to_user(cu,"â€» å°ä¸èµ·ï¼Œé€™å€‹æˆ¿é–“è£¡çš„äººå¤ªå¤šäº†ï¼Œæœ€å¤šè¦15å€‹äºº",0,MSG_MESSA
GE);
    return ;
  }

  /* clear the top table */
  sprintf(buf,"/u2%80s"," ");
  send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  sprintf(buf,"/u3%80s"," ");
  send_to_room(room, buf, 0, MSG_MESSAGE,NULL);
  sprintf(buf,"/u4%80s"," ");
  send_to_room(room, buf, 0, MSG_MESSAGE,NULL);

  room->rflag &= 0x2F;
  kill_clear_user_state(room);
  kill_parse_start_options(room,msg);

  if(count >= 7 && count < 10)
  {
    room->policenum = 0;
    if(room->rflag & ROOM_KILL_POLICE)
      room->policenum = 1;
    if(room->rflag & ROOM_KILL_NOPOLICE)
      room->policenum = 0;
    room->killernum = 2;
    room->normalnum = count - room->policenum - room->killernum ;
  }
  if(count >= 10 && count <= 15)
  {
    room->policenum = 1;
    if(room->rflag & ROOM_KILL_POLICE)
      room->policenum = 1;
    if(room->rflag & ROOM_KILL_NOPOLICE)
      room->policenum = 0;
    room->killernum = 3;
    room->normalnum = count - room->policenum - room->killernum ;
  }
  else if(count >= 15 && count <= 20 )
  {
    room->policenum = 2;
    if(room->rflag & ROOM_KILL_POLICE)
      room->policenum = 1;
    if(room->rflag & ROOM_KILL_NOPOLICE)
      room->policenum = 0;
    room->killernum = 4;
    room->normalnum = count - room->policenum - room->killernum ;
  }
/*
  else if(count >= 15)
  {
    room->policenum = 4;
    room->killernum = 4;
    room->normalnum = count - room->policenum - room->killernum ;
  }
*/

  send_to_room(room,"/c",0,MSG_MESSAGE,NULL);
  send_to_room(room,"\033[1;33m$$         æ–°ä¸€è¼ªæ®ºæ‰‹éŠæˆ²é–‹å§‹äº†ï¼\033[0m",0,MSG_
MESSAGE,NULL);
  if(room->rflag & ROOM_KILL_DISCUSS)
    send_to_room(room,"\033[1;33m$$         å¯ä»¥é€²è¡Œè¨è«–\033[0m",0,MSG_MESSAGE,
NULL);
  else
    send_to_room(room,"\033[1;33m$$         ä¸å¯ä»¥é€²è¡Œè¨è«–\033[0m",0,MSG_MESSAG
E,NULL);
  if(room->rflag & ROOM_KILL_NOGHOST)
    send_to_room(room,"\033[1;33m$$         æ­»äººä¸å¯ä»¥èªªè©±\033[0m",0,MSG_MESSAG
E,NULL);
  else
    send_to_room(room,"\033[1;33m$$         æ­»äººå¯ä»¥èªªè©±\033[0m",0,MSG_MESSAGE,
NULL);

  if(room->policenum > 0)
  {
    if(room->rflag & ROOM_KILL_STRPOLICE)
      send_to_room(room,"\033[1;33m$$         è­¦å¯Ÿæ¯å¤©é–‹å§‹ç™¼ç¾ä¸€å€‹æ®ºæ‰‹\033[0m",
0,MSG_MESSAGE,NULL);
    else
      send_to_room(room,"\033[1;33m$$         è­¦å¯Ÿæ¯å¤©å¯ä»¥æŸ¥è©¢ä¸€æ¬¡\033[0m",0,MS
G_MESSAGE,NULL);

    sprintf(buf,"\033[1;33m$$         å…±æœ‰ %d åè­¦å¯Ÿã€%d åæ®ºæ‰‹å’Œ %d åå¹³æ°‘\033
[0m",room->policenum,room->killernum,room->normalnum);
  }
  else
    sprintf(buf,"\033[1;33m$$         å…±æœ‰ %d åæ®ºæ‰‹å’Œ %d åå¹³æ°‘\033[0m",room->
killernum,room->normalnum);

  send_to_room(room,buf,0,MSG_MESSAGE,NULL);


  kill_random_role(room);

  if(count % 2 == 0)  // esp: å¶æ•¸å¤œé–“é–‹å§‹
  {
    send_to_room(room,"\033[1;33m$$         å› ç‚ºç©å®¶æ•¸ç‚ºå¶æ•¸ï¼Œæ‰€ä»¥å¾æ™šä¸Šé–‹å§‹ã€\
033[0m",0,MSG_MESSAGE,NULL);
    room->killstatus = KILL_NOT_START;
  }
  else  // å¥‡æ•¸ç™½å¤©ç™¼è¨€é–‹å§‹
  {
    send_to_room(room,"\033[1;33m$$         å› ç‚ºç©å®¶æ•¸ç‚ºå¥‡æ•¸ï¼Œæ‰€ä»¥å¾ç™½å¤©é–‹å§‹ã€\
033[0m",0,MSG_MESSAGE,NULL);
    room->killstatus = KILL_DAY_MURDERED;
  }

  room->rflag |= ROOM_KILL_STARTED;

  kill_next_status(room,cu);
}

static void kill_end(cu, msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room = cu->room;

  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"â€» å°ä¸èµ·ï¼Œé€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return ;
  }

  if(cu != NULL && !ROOMOP(cu))
  {
    send_to_user(cu, msg_not_op, 0, MSG_MESSAGE);
    return ;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu, "â€» éŠæˆ²é‚„æ²’é–‹å§‹å‘¢",0,MSG_MESSAGE);
    return ;
  }

  send_to_room(room,"\033[1;33m$$         é€™ä¸€è¼ªçš„éŠæˆ²è¢«æå‰çµæŸäº†\033[0m",0,MS
G_MESSAGE,NULL);

  room->rflag &= ~ROOM_KILL_STARTED;
  room->killstatus = KILL_NOT_START;

  kill_refresh_table(room);

  kill_clear_user_state(room);

}

#if 0
static void kill_sunset(cu,msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room;


  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹",0,MSG_MESSAGE);
    return;
  }

  if(KILL_ROLE(cu) != KILL_JUDGE)
  {
    send_to_user(cu,"$$ ä½ ä¸æ˜¯æ³•å®˜ï¼Œä¸èƒ½ä½¿å¤©é»‘ä¸‹å»",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus != KILL_BEFORENIGHT)
  {
    send_to_user(cu,"$$ ç¾åœ¨é‚„æ²’åˆ°å¤©é»‘çš„æ™‚å€™å‘¢",0,MSG_MESSAGE);
    return;
  }

  kill_next_status(room,cu);

  cu->killstate = KILL_JUDGE_FRESH;
}
static void kill_sunrise(cu,msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room;

  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹",0,MSG_MESSAGE);
    return;
  }

  if(KILL_ROLE(cu) != KILL_JUDGE)
  {
    send_to_user(cu,"$$ ä½ ä¸æ˜¯æ³•å®˜ï¼Œä¸èƒ½ä½¿å¤©äº®èµ·ä¾†",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus != KILL_NIGHT_POLICE)
  {
    send_to_user(cu,"$$ ç¾åœ¨é‚„ä¸æ˜¯ååŠå¤œå‘¢",0,MSG_MESSAGE);
    return;
  }

  kill_next_status(room,cu);

  cu->killstate = KILL_JUDGE_FRESH;
}

static void kill_vote(cu,msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room;


  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹",0,MSG_MESSAGE);
    return;
  }

  if(KILL_ROLE(cu) != KILL_JUDGE)
  {
    send_to_user(cu,"$$ ä½ ä¸æ˜¯æ³•å®˜ï¼Œä¸èƒ½åŸ·è¡ŒæŠ•ç¥¨",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus != KILL_DAY)
  {
    send_to_user(cu,"$$ ç¾åœ¨é‚„ä¸èƒ½æŠ•ç¥¨",0,MSG_MESSAGE);
    return;
  }

  kill_next_status(room,cu);

  cu->killstate = KILL_JUDGE_FRESH;
}

#endif

static void kill_kill(cu,msg)
  ChatUser* cu;
  char* msg;
{
  ChatRoom *room;
  char *twit,buf[80];
  ChatUser *xuser;


  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹\033[0m",0,MSG_MESSAG
E);
    return;
  }

  if(room->rflag & ROOM_KILL_WAITDROP)
  {
    send_to_user(cu,"\033[1;35m$$ é‚„æ˜¯å…ˆç­‰ç­‰æ–·ç·šçš„åŒå¿—å§ã€‚\033[0m",0,MSG_MESSAG
E);
    return;
  }

  if(cu->killflag & KILL_KILLED)
  {
    send_to_user(cu,"\033[1;35m$$ æ­»äººå°±ä¸èƒ½å†æ®ºåˆ¥äººäº†:(\033[0m",0,MSG_MESSAGE)
;
    return;
  }

  if(room->killstatus != KILL_NIGHT_KILLER  && room->killstatus != KILL_DAY_VOT
E)
  {
    send_to_user(cu,"\033[1;35m$$ ç¾åœ¨é‚„ä¸èƒ½æ®ºäºº\033[0m",0,MSG_MESSAGE);
    return;
  }


  twit = nextword(&msg);
  xuser = cuser_by_chatid(twit);

  if(xuser == NULL)
  {
    xuser = cuser_by_userid(twit);
  }

  if(xuser == NULL || xuser->room != room)
  {
    sprintf(buf, msg_no_such_id, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }


  if(room->killstatus == KILL_NIGHT_KILLER
    && KILL_ROLE(cu) != KILL_KILLER)
  {
    send_to_user(cu,"\033[1;35m$$ å¾ˆæŠ±æ­‰ï¼Œç›®å‰åªæœ‰æ®ºæ‰‹æ‰èƒ½æŠ•ç¥¨\033[0m",0,MSG_ME
SSAGE);
    return;
  }

  if(cu->killflag & KILL_VOTED)
  {
    send_to_user(cu,"\033[1;35m$$ æŠ±æ­‰å•¦ï¼Œé€™æ¬¡ä½ å·²ç¶“æŠ•äº†ä¸€ç¥¨äº†\033[0m",0,MSG_ME
SSAGE);
    return;
  }

  if(xuser->killflag & KILL_KNOCKOUT)
  {
    send_to_user(cu,"\033[1;35m$$ ä»–å·²ç¶“æ˜¯å€‹æ­»äººäº†ï¼Œä½ å°±è¡Œè¡Œå¥½å§ã€‚\033[0m",0,MS
G_MESSAGE);
    return;
  }

/* esp: æ—¢ç„¶å¤§å®¶éƒ½è¦ºå¾—æ™šä¸Šä¹Ÿæ‡‰è©²å¯ä»¥æ®ºæ®ºæ‰‹ï¼Œé‚£å°±æ®º */
/*
  if(room->killstatus == KILL_NIGHT_KILLER)
  {
    if(KILL_ROLE(xuser) == KILL_KILLER)
    {
      send_to_user(cu,"\033[1;35m$$ ä¸è¦æ®ºå®³åŒé¡å—ã€‚\033[0m",0,MSG_MESSAGE);
      return;
    }
  }
*/

  // esp: æ®ºæ‰‹åœ¨ç™½å¤©å¯ä»¥æŠ•æ®ºæ‰‹çš„ç¥¨å—ï¼Ÿæˆ‘å°±è®“ä»–å¯ä»¥ï¼Œé€™æ¨£å¯èƒ½æ›´éš±è”½ï¼ŒKAKA

  xuser->votenum ++;
  cu->killflag |= KILL_VOTED;


  if(room->killstatus != KILL_NIGHT_KILLER)
  {
    strcpy(cu->killid,xuser->chatid);
    sprintf(buf,"\033[1;31m$$         ä½ æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",xuser->chatid);
    send_to_user(cu,buf,0,MSG_MESSAGE);
    // sprintf(buf,"\033[1;31m$$         %s æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",cu->chatid,x
user->chatid);
    // send_to_room(room,buf,0,MSG_MESSAGE,NULL);
  }
  else
  {
    sprintf(buf,"\033[1;31m$$         ä½ æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",xuser->chatid);
    send_to_user(cu,buf,0,MSG_MESSAGE);
  }
 //  kill_refresh_table(room);
  kill_check_vote(room,cu);
}

#if 0

static void kill_user_vote(cu,msg)
  ChatUser *cu;
  char* msg;
{
  char *twit, buf[80];
  ChatUser *xuser;
  ChatRoom *room;

  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus != KILL_NIGHT_KILLER
    && room->killstatus != KILL_DAY_VOTE)
  {
    send_to_user(cu,"$$ ç¾åœ¨æ²’æœ‰èˆ‰è¾¦æŠ•ç¥¨",0,MSG_MESSAGE);
    return ;
  }

  if(cu->killflag & KILL_KILLED)
  {
    send_to_user(cu,"$$ æŠ±æ­‰å•¦ï¼Œä½ ç¾åœ¨ç„¡æ¬ŠæŠ•ç¥¨",0,MSG_MESSAGE);
    return;
  }

  if(KILL_ROLE(cu) == KILL_JUDGE)
  {
    send_to_user(cu,"$$ æŠ±æ­‰å•¦ï¼Œæ³•å®˜æ˜¯ä¸èƒ½æŠ•ç¥¨çš„",0,MSG_MESSAGE);
    return;
  }

  if(cu->killflag & KILL_VOTED)
  {
    send_to_user(cu,"$$ æŠ±æ­‰å•¦ï¼Œé€™æ¬¡ä½ å·²ç¶“æŠ•äº†ä¸€ç¥¨äº†",0,MSG_MESSAGE);
    return;
  }

  /* esp: æ®ºè‡ªå·±æ€éº¼è¾¦ï¼Ÿï¼Ÿ --å›ç­”æ˜¯ï¼Œæ‰ä¸ç®¡å‘¢ */
  twit = nextword(&msg);
  xuser = cuser_by_chatid(twit);

  if (xuser == NULL)
  {                       /* Thor.980604: ç”¨ useridä¹Ÿå˜›é€š */
    xuser = cuser_by_userid(twit);
  }

  if (xuser == NULL)
  {
    sprintf(buf, msg_no_such_id, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  room = cu->room;
  if (room != xuser->room || CLOAK(xuser))
  {
    sprintf(buf, msg_not_here, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }

  if(room->killstatus == KILL_NIGHT_KILLER
    && KILL_ROLE(cu) != KILL_KILLER)
  {
    send_to_user(cu,"$$ å¾ˆæŠ±æ­‰ï¼Œç›®å‰åªæœ‰æ®ºæ‰‹æ‰èƒ½æŠ•ç¥¨",0,MSG_MESSAGE);
    return;
  }

  xuser->votenum ++;
  kill_refresh_table(room);
}

#endif

static void kill_refresh_table(room)
  ChatRoom* room;
{
  int c,line;
  ChatUser *cu,*user;
  char buf[384],buf2[128];

  if(!room)
    return ;


  for(cu = mainuser;cu;cu = cu->unext)
  {
    if(!cu->userno)
      continue;
    if(cu->room != room)
      continue;

    line = 2;
    sprintf(buf,"/u%d ",line);
    for(c = 0,user = mainuser;user;user = user->unext)
    {
      if(!user->userno)
        continue;
      if(user->room != room)
        continue;

      if(room->killstatus == KILL_NOT_START)
        sprintf(buf2,"%s%-12s%s%s",userkillstatecolors[user->killstate],user->c
hatid,"\033[0m",(c < 4 ? "â”‚" : "  "));
      else
        sprintf(buf2,"%s%s%-12s%s%s",userkillstatecolors[kill_get_user_state(ro
om,cu,user)],room->currenttalker == user?"\033[7m":"",user->chatid,"\033[0m",(c
 < 4 ? "â”‚" : "  "));
      strcat(buf,buf2);
      if(++c == 5) // esp: I put 5 user per line, so i can more space
      {
        send_to_user(cu,buf,0,MSG_MESSAGE);
        line ++;
        c = 0;
        sprintf(buf,"/u%d ",line);
      }
    }
    if (c > 0)    send_to_user(cu, buf, 0, MSG_MESSAGE);
  }
}

static void kill_over(cu, msg)
  ChatUser *cu;
  char *msg;
{
  ChatRoom *room;

  room = cu->room;

  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹\033[0m",0,MSG_MESSAG
E);
    return;
  }

  if(room->rflag & ROOM_KILL_WAITDROP)
  {
    send_to_user(cu,"\033[1;35m$$ é‚„æ˜¯ç­‰ç­‰æ–·ç·šçš„åŒå¿—å§ï¼Œå¤šèªªæœƒå…’ï¼Œå¤šèªªå…’æœƒå…’ã€‚\
033[0m",0,MSG_MESSAGE);
    return;
  }

  if(room->killstatus == KILL_DAY_TALK
    || room->killstatus == KILL_DAY_MURDERED
    || room->killstatus == KILL_BEFORENIGHT
    && room->currenttalker == cu
  )
  {

    kill_talk_over(room,cu);
  }
  else
  {
    send_to_user(cu,"\033[1;35m$$ æ‚¨ç¾åœ¨æ ¹æœ¬å°±ä»€éº¼éƒ½æ²’å¹¹\033[0m",0,MSG_MESSAGE)
;
  }

  return;
}

#if 0

static void kill_killer_over(room,cu)
  ChatRoom *room;
  ChatUser *cu;
{
  if(cu->killflag & KILL_KNOCKOUT)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ çš„é­‚éˆé‚„æ²’æœ‰å›åˆ°èº«é«”è£¡å‘¢\033[0m",0,MSG_MESS
AGE);
    return;
  }

  if(cu->killflag & KILL_TALKED)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ å·²ç¶“çµæŸæ™šä¸Šçš„æ´»å‹•äº†\033[0m",0,MSG_MESSAGE)
;
    return;
  }

  cu->killflag |= KILL_TALKED;

  kill_on_user_over(room);
}

static void kill_police_over(room,cu)
  ChatRoom *room;
  ChatUser *cu;
{
  if(cu->killflag & KILL_KNOCKOUT)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ çš„é­‚éˆé‚„æ²’æœ‰å›åˆ°èº«é«”è£¡å‘¢\033[0m",0,MSG_MESS
AGE);
    return;
  }

  if(cu->killflag & KILL_TALKED)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ å·²ç¶“çµæŸæ™šä¸Šçš„æ´»å‹•äº†\033[0m",0,MSG_MESSAGE)
;
    return;
  }

  cu->killflag |= KILL_TALKED;
  kill_on_user_over(room);
}

#endif

static void kill_talk_over(room,cu)
  ChatRoom *room;
  ChatUser *cu;
{
  ChatUser *user;
  char buf[128];

  if(cu->killflag & KILL_KNOCKOUT)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ çš„é­‚éˆé‚„æ²’æœ‰å›åˆ°èº«é«”è£¡å‘¢\033[0m",0,MSG_MESS
AGE);
    return;
  }

  if(cu->killflag & KILL_TALKED)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ å·²ç¶“çµæŸç™¼è¨€äº†\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(cu != room->currenttalker)
  {
    send_to_user(cu,"\033[1;35m$$ ä½ æ ¹æœ¬å°±æ²’æœ‰åœ¨ç™¼è¨€\033[0m",0,MSG_MESSAGE);
    return;
  }
  sprintf(buf,"\033[1;33m$$         %s çš„ç™¼è¨€å·²ç¶“çµæŸäº†\033[0m",cu->chatid);
  send_to_room(room,buf,0,MSG_MESSAGE,NULL);

  cu->killflag |= KILL_TALKED;
  if(!kill_on_user_over(room))
  {
    user = kill_get_next_user(room,cu);
    room->currenttalker = user;
    user->tkillbegin = time(0);
    sprintf(buf,"\033[1;33m$$         ç¾åœ¨ç”± %s ç™¼è¨€\033[0m",user->chatid);
    send_to_room(room,buf,0,MSG_MESSAGE,NULL);
    kill_refresh_table(room);
  }
}

static int kill_on_user_over(room)
  ChatRoom *room;
{
  ChatUser *user;
  int count = 0;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    if(room->killstatus == KILL_DAY_MURDERED)
    {
      kill_next_status(room,NULL);
      return 1;
    }
    if(room->killstatus == KILL_BEFORENIGHT)
    {
      kill_next_status(room,NULL);
      return 1;
    }
    else if(room->killstatus == KILL_DAY_TALK)
    {
        if(user->killflag & KILL_TALKED || user->killflag & KILL_KNOCKOUT)
        {
          count ++;
          if(count == room->policenum + room->normalnum + room->killernum)
          {
            kill_next_status(room,NULL);
            return 1;
          }
        }
    }
  }

  return 0;

}

static ChatUser *kill_get_next_user(room,cu)
  ChatRoom *room;
  ChatUser *cu;
{
  ChatUser *user,*prevuser;
  if(!room)
    return NULL;

  prevuser = NULL;
  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    if(room->killstatus == KILL_DAY_TALK)
    {
      if(!(user->killflag & KILL_KNOCKOUT))
      {
        if(prevuser == cu)
          return user;
        prevuser = user;
      }
    }
  }


  return NULL;
}

static void kill_check_vote(room,cu)
  ChatRoom* room;
  ChatUser* cu;
{
  int max = 0, count = 0;

  ChatUser *user,*maxuser = NULL;
  char buf[128];

  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(room->killstatus == KILL_NIGHT_KILLER)
    {
      if(KILL_ROLE(user) == KILL_KILLER && !(user->killflag & KILL_KNOCKOUT)
        && !(user->killflag & KILL_VOTED))
        return ;
    }
    else if(room->killstatus == KILL_DAY_VOTE)
    {
      if(!(user->killflag & KILL_KILLED)
        && !(user->killflag & KILL_VOTED))
      {
        return ;
      }
    }
    else
      return;
  }


  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(user->killflag & (KILL_KNOCKOUT | KILL_KILLED))
      continue;

    /* esp: zk told me to show the vote detail together */
    if(room->killstatus == KILL_DAY_VOTE)
    {
      sprintf(buf,"\033[1;31m$$         %s æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",user->chatid,
user->killid);
      send_to_room(room,buf,0,MSG_MESSAGE,NULL);
    }

    if(user->votenum > max)
    {
      maxuser = user;
      max = user->votenum;
      count = 1;
    }
    else if(user->votenum == max)
    {
      count ++;
    }
  }


  if(count != 1)
  {
    kill_clear_user_vote(room);
    kill_enable_user_vote(room);

    // kill_refresh_table(room);

    if(room->killstatus == KILL_NIGHT_KILLER)
      send_to_room(room,"\033[1;35m$$ æœ‰å¹¶åˆ—ç¬¬ä¸€çš„ï¼Œç¾åœ¨å¤§å®¶é‡æ–°æŠ•ç¥¨å§\033[0m",
0,MSG_MESSAGE,cu);
    else
      send_to_room(room,"\033[1;35m$$ æœ‰å¹¶åˆ—ç¬¬ä¸€çš„ï¼Œç¾åœ¨å¤§å®¶é‡æ–°æŠ•ç¥¨å§\033[0m",
0,MSG_MESSAGE,NULL);
    return;
  }

  user = maxuser;
  user->killflag |= KILL_KILLED;
  if(room->killstatus == KILL_NIGHT_KILLER)
  {
    if(KILL_ROLE(user) == KILL_KILLER)
      user->killstate = KILL_USER_KILLED_KILLER;
    else if(KILL_ROLE(user) == KILL_POLICE)
      user->killstate = KILL_USER_KILLED_POLICE;
    else if(KILL_ROLE(user) == KILL_NORMAL)
      user->killstate = KILL_USER_KILLED_NORMAL;
  }
  else
  {
    // esp: should be KILL_DAY_VOTE
    if(KILL_ROLE(user) == KILL_KILLER)
      user->killstate = KILL_USER_KILLED_KILLER;
    else if(KILL_ROLE(user) == KILL_POLICE)
      user->killstate = KILL_USER_MISKILLED_POLICE;
    else if(KILL_ROLE(user) == KILL_NORMAL)
      user->killstate = KILL_USER_MISKILLED_NORMAL;
  }


  kill_next_status(room,NULL);

}

static void kill_on_reconnect(room)
  ChatRoom* room;
{
  ChatUser *user;
  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(user->killflag & KILL_DROPED)
      return;
  }

  room->rflag &= ~ROOM_KILL_WAITDROP;
}

static void kill_parse_start_options(room,msg)
  ChatRoom *room;
  char* msg;
{
  int police = 0,nopolice = 0,discuss = 0,noghost = 0;
  int strpolice = 0;
  char *str;

  if(!msg)
    return ;
  str = nextword(&msg);
  while(str && *str)
  {
    if(!strcmp(str,"police"))
      police = 1;
    else if(!strcmp(str,"nopolice"))
      nopolice = 1;
    else if(!strcmp(str,"discuss"))
      discuss = 1;
    else if(!strcmp(str,"noghost"))
      noghost = 1;
    else if(!strcmp(str,"strpolice"))
      strpolice = 1;
    str = nextword(&msg);
  }
  if(police == 1)
    room->rflag |= ROOM_KILL_POLICE;
  if(nopolice == 1)
    room->rflag |= ROOM_KILL_NOPOLICE;
  if(discuss == 1)
    room->rflag |= ROOM_KILL_DISCUSS;
  if(noghost == 1)
    room->rflag |= ROOM_KILL_NOGHOST;
  if(strpolice == 1)
    room->rflag |= ROOM_KILL_STRPOLICE;

}

static void kill_police_query(cu, msg)
  ChatUser *cu;
  char *msg;
{
  ChatRoom *room;
  char *twit,buf[80];
  ChatUser *xuser;


  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹\033[0m",0,MSG_MESSAG
E);
    return;
  }

  if(cu->killflag & KILL_KILLED)
  {
    send_to_user(cu,"\033[1;35m$$ æ­»äººå°±ä¸èƒ½å†æŸ¥è©¢åˆ¥äººäº†:(\033[0m",0,MSG_MESSAG
E);
    return;
  }

  twit = nextword(&msg);
  xuser = cuser_by_chatid(twit);

  if(xuser == NULL)
  {
    xuser = cuser_by_userid(twit);
  }

  if(xuser == NULL || xuser->room != room)
  {
    sprintf(buf, msg_no_such_id, twit);
    send_to_user(cu, buf, 0, MSG_MESSAGE);
    return;
  }


  if(KILL_ROLE(cu) != KILL_POLICE)
  {
    send_to_user(cu,"\033[1;35m$$ åªæœ‰è­¦å¯Ÿæ‰èƒ½æŸ¥è©¢åˆ¥äºº\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(room->rflag & ROOM_KILL_STRPOLICE)
  {
    send_to_user(cu,"\033[1;35m$$ ä¸å¿…æŸ¥è©¢ï¼Œä½ æœƒæ…¢æ…¢çŸ¥é“çš„\033[0m",0,MSG_MESSAG
E);
    return;
  }

  if(cu->killflag & KILL_QUERYED)
  {
    send_to_user(cu,"\033[1;35m$$ æŠ±æ­‰å•¦ï¼Œä»Šå¤©ä½ å·²ç¶“æŸ¥è©¢éäº†\033[0m",0,MSG_MESS
AGE);
    return;
  }

  xuser->killflag |= KILL_QUERYED ;
  cu->killflag |= KILL_QUERYED;


  sprintf(buf,"\033[1;31m$$ %s çš„èº«ä»½æ˜¯ %s%s%sï¼\033[0m",
    xuser->chatid, userkillstatecolors[xuser->killstate],
    userkillstates[xuser->killstate],"\033[0m");
  send_to_user(cu,buf,0,MSG_MESSAGE);

}

static void kill_show_next_killer(room)
  ChatRoom *room;
{
  ChatUser * user;

  for(user = mainuser;user;user = user->unext)
  {
    if(!user->userno)
      continue;
    if(user->room != room)
      continue;

    if(KILL_ROLE(user)==KILL_KILLER && !(user->killflag & KILL_QUERYED))    {
       user->killflag |= KILL_QUERYED;
       return;
    }
  }
}

static void kill_talk_time_check(room)
  ChatRoom *room;
{
  int timelimit; // in seconds
  if(!(room->rflag & ROOM_KILL_STARTED))
    return;

  if(NULL == room->currenttalker)
    return;

  if(room->killstatus == KILL_DAY_MURDERED
    || room->killstatus == KILL_BEFORENIGHT)
    timelimit = 60;
  else if(room->killstatus == KILL_DAY_TALK)
    timelimit = 45;
  else
    return;

  if(time(0) - room->currenttalker->tkillbegin > timelimit)
    kill_talk_over(room,room->currenttalker);

  return;
}

static void kill_vote_time_check(room)
  ChatRoom *room;
{
  int timelimit = 30;
  if(!(room->rflag & ROOM_KILL_STARTED))
    return;
  if(room->killstatus != KILL_NIGHT_KILLER
    && room->killstatus != KILL_DAY_VOTE)
  return;

  if(room->killstatus == KILL_NIGHT_KILLER)
    timelimit = 60;

  if(time(0) - room->tvotebegin > timelimit)
  {
    kill_auto_vote(room);
  }

  return;
}


static ChatUser* 
kill_auto_vote(room)
  ChatRoom *room;
{
  int max = 0, count = 0;
  int r,total = 0;

  ChatUser *user,*maxuser = NULL;
  char buf[128];

  for(user = mainuser;user;user = user->unext)
  {
    if(user->room != room)
      continue;

    if(user->killflag & (KILL_KNOCKOUT | KILL_KILLED))
      continue;


    if(user->votenum > max)
    {
      maxuser = user;
      max = user->votenum;
      count = 1;
    }
    else if(user->votenum == max  && max != 0)
    {
      count ++;
    }
  }

  if(count == 0)
  {
    // nobody voted
    total = room->policenum + room->killernum + room->normalnum;
    srand(time(0));

    r = (float) rand() / RAND_MAX * total;
    do {
      user = chat_get_nth_user(room,r+1);
      r = (r + 1) % total;
    } while( user->killflag & KILL_KILLED);

    // now , the 'user' should be the poor guy.
  }
  else if(count != 1)
  {
     // more than one elected, we random one out
     srand(time(0));
     total = room->policenum + room->killernum + room->normalnum;
     r = (float) rand() / RAND_MAX * count;
     count = 0;
     for(user = mainuser;user;user=user->unext)
     {
        if(user->room != room)
          continue;
        if(user->userno == 0)
          continue;
        if(user->killflag & KILL_KILLED)
          continue;
        if(user->votenum != max)
          continue;
        count ++;
        if(count >= r+1)
          break;
     }
   }
   else
   {
      user = maxuser;
    }

   maxuser = user;

   for(user = mainuser;user;user=user->unext)
   {
      if(user->room != room)
        continue;
      if(user->userno == 0)
        continue;
      if(user->killflag & KILL_KILLED)
        continue;

      if(room->killstatus == KILL_NIGHT_KILLER)
        if(KILL_ROLE(user) != KILL_KILLER)
          continue;

      if(!(user->killflag & KILL_VOTED))
      {
        maxuser->votenum ++;
        user->killflag |= KILL_VOTED;

        if(room->killstatus != KILL_NIGHT_KILLER)
        {
           strcpy(user->killid,maxuser->chatid);
           sprintf(buf,"\033[1;31m$$         ä½ æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",maxuser->
chatid);
           send_to_user(user,buf,0,MSG_MESSAGE);
         }
         else
         {
           sprintf(buf,"\033[1;31m$$         ä½ æŠ•äº† %s ä¸€ç¥¨ï¼\033[0m",maxuser->
chatid);
           send_to_user(user,buf,0,MSG_MESSAGE);
          }
            kill_check_vote(room,user);
       }
    }
}

static void kill_kkk(cu,msg)
  ChatUser *cu;
  char* msg;
{
  ChatRoom *room;


  room = cu->room;
  if(room == ROOM_ALL || !(room->rflag & ROOM_KILLGAME))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“ä¸æ˜¯éŠæˆ²æˆ¿é–“\033[0m",0,MSG_MESSAGE);
    return;
  }

  if(!(room->rflag & ROOM_KILL_STARTED))
  {
    send_to_user(cu,"\033[1;35m$$ é€™å€‹æˆ¿é–“çš„éŠæˆ²é‚„æ²’æœ‰é–‹å§‹\033[0m",0,MSG_MESSAGE);
    return;
  }

  kill_talk_time_check(room);
  kill_vote_time_check(room);

}

static void kill_log_state(user, nmode)
  ChatUser *user;
  int nmode;
{
  char fpath[80];
  FILE *fp;
  KILL_STATE killstate;


  memset(&killstate,0,sizeof(KILL_STATE));
  usr_fpath(fpath,user->userid,".KILLGAME");
  fp = fopen(fpath,"rb");
  if(NULL != fp)
  {
    fread(&killstate,sizeof(KILL_STATE),1,fp);
    fclose(fp);
  }

  switch(nmode)
  {
  case 1:
    killstate.won ++;
    break;
  case 2:
    killstate.lost ++;
    break;
  case 3:
    killstate.dropped ++;
    break;
  default:
    break;
  }

  killstate.lastgame = nmode;
  killstate.tlastgame = time(0);

  fp = fopen(fpath,"wb+");
  if(NULL != fp)
  {
    fwrite(&killstate,sizeof(KILL_STATE),1,fp);
    fclose(fp);
  }

}

static void
kill_show_state(cu, msg)
  ChatUser *cu;
  char *msg;
{
  char fpath[80], *twit;
  FILE *fp;
  KILL_STATE killstate;
  struct stat st;
  static char* gamedesc[4] = {
    "","Won","Lost","Dropped"};


  twit = nextword(&msg);
  if(twit == NULL || *twit == 0)
    twit = cu->userid;

  usr_fpath(fpath,twit,FN_ACCT);
  if(-1 == stat(fpath,&st))
  {
    send_to_user(cu,"\033[1;35m$$ æ²’æœ‰é€™ä½ä½¿ç”¨è€…!\033[0m",0,MSG_MESSAGE);
    return;
  }
  memset(&killstate,0,sizeof(KILL_STATE));

  usr_fpath(fpath,twit,".KILLGAME");
  fp = fopen(fpath,"rb");
  if(NULL != fp)
  {
    fread(&killstate,sizeof(KILL_STATE),1,fp);
    fclose(fp);

    sprintf(fpath,"\033[1;33m$$ %s:\033[m",twit);
    send_to_user(cu,fpath,0,MSG_MESSAGE);
    sprintf(fpath,"\033[1;33m$$ Scores: %d-%d-%d\033[m",
      killstate.won,killstate.lost,killstate.dropped);
    send_to_user(cu,fpath,0,MSG_MESSAGE);
    sprintf(fpath,"\033[1;33m$$ Lastgame: %s at %s\033[m",
      gamedesc[killstate.lastgame],Btime(&(killstate.tlastgame)));
    send_to_user(cu,fpath,0,MSG_MESSAGE);

  }
  else
  {
    send_to_user(cu,"\033[1;35m$$ é€™ä½ä½¿ç”¨è€…æ²’æœ‰ç©ééŠæˆ²\033[0m",0,MSG_MESSAGE);
  }
  return;

}

#endif /* HAVE_KILL_GAME */





--
[1;37;40m                 [34mâ–¡[37m      [34mâ–¡[37m   [34mâ–¡[36m [37m     [34mâ–¡[37m
      [33mâ–¡â–¡â–¡[37m     [34mâ–¡[0;40mâ–¡â–¡â–¡[0;1;34mâ–¡[37m   [34mâ–¡[0;40mâ–¡â–¡â–¡[1;34mâ–¡[37m     [33mâ–¡â–¡â–¡[37m
        [33mâ–¡ [37m      [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m   [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m       [33mâ–¡[37m
        [33mâ–¡[37m       [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m   [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m       [33mâ–¡[37m
        [33mâ–¡[37m       [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m   [34mâ–¡[0;5;37mâ–¡[0;1;37;40m  [0;5;30;47mâ–¡[0;1;34mâ–¡[37m       [33mâ–¡[37m               [36m     [37m
      [33mâ–¡â–¡â–¡  [37m   [34mâ–¡â–¡â–¡â–¡â–¡[37m  [36m [34mâ–¡â–¡â–¡â–¡â–¡[37m     [33mâ–¡â–¡â–¡[37m  [36m~~å”‰ å‘¦å‘¦~~~~~~[33m [37m
--
[1;32mâ€» Origin: [33mã€åŒ—éƒµçœŸæƒ…æµéœ²ã€‘ [37m<bupt.org> [m[1;31mâ—† From: [36m202.112.254.105[m
