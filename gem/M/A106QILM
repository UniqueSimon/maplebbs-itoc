ç™¼ä¿¡äºº: Efen.bbs@bbs.med.ncku.edu.tw (^^) çœ‹æ¿: plan
æ¨™  é¡Œ: [åŠŸèƒ½]POP3éƒµä»¶ä¼ºæœå™¨
ç™¼ä¿¡ç«™: è¿´é¢¨è°· (2004/04/02 Fri 13:22:41)                  Updated: 2004/04/03

å¾Windtopé‚£é‚Šè½‰æ¤éä¾†çš„ã€‚

: modes.h

#define XZ_GEM          (XO_ZONE + 13)  /* ç²¾è¯å€ */
+ #define XZ_MIME       (XO_ZONE + 14)  /* MIME æ”¶ä¿¡ */

: ufo.h

#define UFO_LOGINCLOAK  BFLAG(21)       /* ä¸Šç«™ç›´æ¥éš±èº« */
+ #define UFO_MIME      BFLAG(22)       /* MIME è§£ç¢¼ */

  "éš±èº«ä¸Šç«™        (éš±èº«/ç¾èº«)",        /* UFO_LOGINCLOAK */
+ "MIMEç·¨ç¢¼        (é–‹å•Ÿ/é—œé–‰)",        /* UFO_MIME */

: global.h

+ #define FN_MAILSERVICE_LOG  "run/mailservice.log"   /* MailSevice ä½¿ç”¨ç´€éŒ„ */
+ #define FN_ETC_MAILSERVICE  "etc/mailservice"       /* é›»å­éƒµä»¶æœå‹™ */

: theme.h

+ #define FEETER_POP3     \
COLOR1 " POP3æœå‹™ " COLOR2 " (y)å›ä¿¡ (F/x)è½‰å¯„ (d)åˆªé™¤ (D)å€æ®µåˆªé™¤ (m)æ¨™è¨˜
 \033[m"

: maple.p

+/* socket.c */
+int Get_Socket(char *site,int *sock);

: admutil.c

    "æ”¶ä¿¡ç™½åå–®",
    "æ”¶ä¿¡é»‘åå–®",

#ifdef HAVE_LOGIN_DENIED
    "æ‹’çµ•é€£ç·šåå–®",
#endif
+   "POP3æœå‹™èªªæ˜",


    MAIL_ACLFILE,
    UNMAIL_ACLFILE,

#ifdef HAVE_LOGIN_DENIED
    BBS_ACLFILE,
#endif
+   FN_ETC_MAILSERVICE,

: menu.c

æ‰¾åœ°æ–¹åŠ ä¸Š
  "bin/pop3mail.so:Pop3mail", PERM_BASIC, -M_XMODE,
  "Pop3       â”œ POP3 éƒµä»¶â”¤",

: so/Makefile

åŠ ä¸Š pop3mail.so

: ~/mailservice

éœ€è¦åœ¨/home/bbsä¹‹ä¸‹ï¼Œ
mkdir mailservice

: so/pop3mail.c

åŠ ä¸Šä¸‹é¢é€™æ®µç¨‹å¼
..é€™éƒ¨åˆ†é‚„æœ‰å•é¡Œï¼Œè½‰ä¿¡/å¯„ä¿¡/å›ä¿¡çš„å‹•ä½œéƒ½å¯ä»¥äº†ï¼Œ
åªæ˜¯åˆªæ–‡çš„éƒ¨åˆ†é‚„æ²’æ”¹å¥½â€¦
åŸä¾†çš„åˆªæ–‡æ˜¯ç”¨å¤§Dæ¨™å¥½ï¼Œç„¶å¾Œé›¢é–‹æ™‚å•ä½ è¦ä¸è¦åˆªé™¤(WindTopéƒ½é€™æ¨£???)
æœ€å¾Œé›¢é–‹ä¼ºæœå™¨æ™‚å†åˆªæ‰

ç¾åœ¨æˆ‘æ”¹äº†å‰åŠï¼Œè®“ä»–ç›´æ¥åˆªæ‰â€¦
ç„¶å¾Œå¾ŒåŠé‚„æ²’æƒ³åˆ°æ€éº¼æ”¹â€¦
so...^^;;è®Šæˆæ²’è¾¦æ³•æœ‰æ•ˆçš„åˆªä»¶ï¼Œåªæ˜¯è‡ªå·±ç€è¦½æ™‚ï¼Œåˆªå¥½ç©çš„ï¼Œ
é ç«¯çš„mail serverä¸æœƒå—åˆ°å½±éŸ¿ï¼@.@


/*-------------------------------------------------------*/
/* pop3mail.c       ( YZU WindTop BBS )                  */
/*-------------------------------------------------------*/
/* author : statue.bbs@bbs.yzu.edu.tw                    */
/* author : visor.bbs@bbs.yzu.edu.tw                     */
/* target : pop3 mail client in mime transfer            */
/* create : 2000/06/22                                   */
/* update : 2000/07/11                                   */
/* rfc    : 1734, 1939, 2449, 1225                       */
/*-------------------------------------------------------*/

#include "bbs.h"

#define MIME_BASE64     0x10000000
#define MIME_QP         0x20000000
#define MIME_MIME       0x40000000

static int is_mime; /* åˆ‡æ› MIME ç”¨çš„æ——æ¨™ */
static int is_base64;
static int is_qp;
static int is_bbsmail;
static char boundary[128];

extern XZ xz[];
extern char xo_pool[];

static FILE *fsock; /* é€£ç·šç”¨çš„ FILE */

static int del_num; /* ç”¨ä¾† UnDelete ç”¨ , å·²åˆªé™¤æ–‡ç« æ•¸*/

extern int TagNum;
static int server_login();
static char *pop3_mime_transfer(unsigned char *);


static void
logitfile(file, key, msg)
  char *file;
  char *key;
  char *msg;
{
  time_t now;
  struct tm *p;
  char buf[100];

  time(&now);
  p = localtime(&now);
  sprintf(buf, "%02d/%02d/%02d %02d:%02d:%02d %s %-14s %s\n",
    p->tm_year % 100, p->tm_mon + 1, p->tm_mday,
    p->tm_hour, p->tm_min, p->tm_sec, key, cuser.userid, msg ? msg : "");
  f_cat(file, buf);
}


/* ----------------------------------------------------- */
/* QP code : "0123456789ABCDEF"                          */
/* QP æ˜¯ä¸€ç¨®è§£ç¢¼æ–¹å¼ quoted-printable                    */
/* ä¸€ç¯‡æ–‡ç« ä¸­çš„ '=' æœ‰æ²’æœ‰è¶…éä¸€å®šæ•¸ç›®.                  */
/* ----------------------------------------------------- */

static int
qp_code(x)
  register int x;
{
  if (x >= '0' && x <= '9')
    return x - '0';
  if (x >= 'a' && x <= 'f')
    return x - 'a' + 10;
  if (x >= 'A' && x <= 'F')
    return x - 'A' + 10;
  return -1;
}

/* ------------------------------------------------------------------ */
/* BASE64 :                                                           */
/* "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" */
/* Base64ç„¡æ³•åˆ¤æ–·, é™¤éæˆ‘å€‘æœ‰header                                   */
/* ------------------------------------------------------------------ */

static int
base64_code(x)
  register int x;
{
  if (x >= 'A' && x <= 'Z')
    return x - 'A';
  if (x >= 'a' && x <= 'z')
    return x - 'a' + 26;
  if (x >= '0' && x <= '9')
    return x - '0' + 52;
  if (x == '+')
    return 62;
  if (x == '/')
    return 63;
  return -1;
}

/* ----------------------------------------------------- */
/* judge & decode QP / BASE64                            */
/* ----------------------------------------------------- */

/* å»é™¤ä¸å¿…è¦çš„æ¨™é ­ */
static int
pop3_mime_cut(unsigned char* src,HDR *hdr, FILE *fp,FILE *sock)
{
  char *ptr;

  /* è‹¥æ²’æœ‰é–‹å•Ÿ MIME è§£ç¢¼é¸é …å‰‡ä¸äºˆè§£ç¢¼ */
  if(!is_mime)
    return 1;

  if(*boundary != 0 && !strncmp(src+2,boundary,strlen(boundary)-2))
  {
    fprintf(fp, "> ------------------------------------------------------------
----------- <\n"
);
    return -1;
  }
  if(str_str(src,"<pre>"))
    return -1;

  if(str_str(src,"</pre>"))
  {
    hdr->xmode |= MIME_MIME;
    return 0;
  }

  if(!strncmp(src, "----", strlen("----"))||
     !strncmp(src, "\tboundary", strlen("\tboundary")))
    return 0; /* è·³éæ­¤éƒ¨ä»½è§£ç¢¼ */

#if 1
  if(!strncmp(src, "Content-Type: ", strlen("Content-Type: ")))
  {
    ptr = src + strlen("Content-Type: ");
    if(!str_ncmp(ptr, "text/html",strlen("text/html")))
    {
      hdr->xmode |= MIME_MIME;
      fprintf(fp, "html æœ‰ç¶²é æ ¼å¼\n");
      return 0;
    }
    if(!str_ncmp(ptr, "image",strlen("image")))
    {
      hdr->xmode |= MIME_MIME;
      fprintf(fp, "image æœ‰é™„ä»¶ : åœ–ç‰‡æª”\n");
      return 0;
    }
    if(!str_ncmp(ptr, "audio",strlen("audio")))
    {
      hdr->xmode |= MIME_MIME;
      fprintf(fp, "audio æœ‰é™„ä»¶ : éŸ³æ•ˆæª”\n");
      return 0;
    }
    if(!str_ncmp(ptr, "video",strlen("video")))
    {
      hdr->xmode |= MIME_MIME;
      fprintf(fp, "video æœ‰é™„ä»¶ : å½±éŸ³æª”\n");
      return 0;
    }
    if(!str_ncmp(ptr, "application",strlen("application")))
    {
      hdr->xmode |= MIME_MIME;
      fprintf(fp, "application æœ‰é™„ä»¶ : ä¸æ˜æ ¼å¼\n");
      return 0;
    }
    hdr->xmode &= (MIME_QP|MIME_BASE64);

    /* é‡åˆ° text or image çµæŸè§£ç¢¼å‹•ä½œ */
    fgets(src, 256, sock);
    if(*src == '\t') /* Contect-Type å¾Œæœ‰ boundary & charset,å‰æœƒæœ‰ tab */
    {
      return 0;
    }
  }
#endif
  if(!str_ncmp(src, "\tname", strlen("\tname")))
  {
    char *end;
    ptr = strstr(src,"name");
    ptr = strchr(ptr,'"');
    end = strchr(ptr+1,'"');
    *end = 0;
    fprintf(fp, "\té™„ä»¶åç¨± : %s\n",pop3_mime_transfer((char *)ptr+1));
    return 0;
  }
  if(!strncmp(src, "Content-Transfer-Encoding: ", strlen("Content-Transfer-Enco
ding: ")))
  { /* è§£ rfc1522 body code */
    ptr = src + strlen("Content-Transfer-Encoding: ");
    if(!strncmp(ptr, "base64", strlen("base64")))
    {
      hdr->xmode |= MIME_BASE64;
      hdr->xmode &= ~MIME_QP;
    }
    if(!strncmp(ptr, "quoted-printable", strlen("quoted-printable")))
    {
      hdr->xmode |= MIME_QP;
      hdr->xmode &= ~MIME_BASE64;
    }
    return 0;
  }
  if(hdr->xmode & MIME_MIME)
    return 0;

  return 1; /* é€²è¡Œè§£ç¢¼å‹•ä½œ */
}

/* è§£ç¢¼ , è·Ÿ bmtad.c çš„ multipart() å¾ˆåƒ*/
static char*
pop3_mime_transfer(unsigned char* src)
{
  unsigned char* dst = src;
  char *ans;
  register int is_done;
  register int c1, c2, c3, c4;

  /* è‹¥æ²’æœ‰é–‹å•Ÿ MIME è§£ç¢¼é¸é …å‰‡ä¸äºˆè§£ç¢¼ */
  if(!is_mime)
    return src;

  ans = src;

   /* åˆ¤æ–·å‰ 10 å€‹å­—å…ƒæ˜¯å¦éƒ½åœ¨base64 ä¸­ */
  for (c1 = 0; c1 < 10 ; c1++)
     if (base64_code(src[c1]) == -1)
     {
        is_base64 = 0;
        break;
     }
  for (is_done = 0; c1 = *src; src++) /* æŠŠå‚³é€²ä¾†çš„å€¼ä½œè§£ç¢¼ */
  {
    if (c1 == '?' && src[1] == '=') /* qb code çš„ To: From: */
    {
      if(src[2] == ' ') /* é€šå¸¸ qb code æˆ– base64 çš„ç¬¬ä¸‰å€‹ä¸æœƒæ˜¯ç©ºç™½ */
      {
        src++;
        is_qp = is_base64 = 0;
      }
      continue;
    }
    else if ((c1 == '=') && (src[1] == '?'))
    {
      /* c2 : qmarks, c3 : code_kind */

      c2 = c3 = 0;

      for (;;)
      {
        c1 = *++src;
        if (c1 != '?')
        {
          if (c2 == 2)
            c3 = c1 | 0x20;
        }
        else
        {
          if (++c2 >= 3)
            break;
        }
      }

      if (c3 == 'q') /* =?q */
        is_qp = MIME_QP;
      else if (c3 == 'b') /* =?big5? */
        is_base64 = MIME_BASE64;
    }
    else if (c1 == '\n')        /* chuan: multi line encoding */
    {
      if (!is_base64)
         *dst++ = c1;
      is_done = is_qp = is_base64 = 0;
      continue;
    }
    else if (is_qp && c1 == '=')
    {
      c1 = *++src;
      if (!*src)
         break;
      c2 = *++src;
      if (!*src)
         break;
      *dst++ = (qp_code(c1) << 4) | qp_code(c2);
      if (dst[-1] == (unsigned char)-1)
         --dst;
    }
    else if (is_base64 && !is_done)
    {
      while (isspace(c1))
      {
        c1 = *++src;
      }
      if (!c1)
        break;
      do
      {
        c2 = *++src;
      } while (isspace(c2));
      if (!c2)
        break;
      do
      {
        c3 = *++src;
      } while (isspace(c3));
      if (!c3)
        break;
      do
      {
        c4 = *++src;
      } while (isspace(c4));
      if (!c4)
        break;
      if (c1 == '=' || c2 == '=')
      {
        is_done = 1;
        continue;
      }
      c2 = base64_code(c2);
      *dst++ = (base64_code(c1) << 2) | ((c2 & 0x30) >> 4);
      if (c3 == '=')
        is_done = 1;
      else
      {
        c3 = base64_code(c3);
        *dst++ = ((c2 & 0xF) << 4) | ((c3 & 0x3c) >> 2);
        if (c4 == '=')
          is_done = 1;
        else
        {
          *dst++ = ((c3 & 0x03) << 6) | base64_code(c4);
        }
      }
    }
    else
      *dst++ = c1;
  }
  if (!is_base64 && dst[-1] == '=')
     dst[-1] = '\n';
  *dst = '\0';
  return ans;
}

static int
int_len(num)
  int num;
{
  int i;
  i = 1;
  while((num/10) > 0)
  {
    num/=10;
    i++;
  }
  return i;
}

/* æŠŠä¾†æºå–å‡ºéœ€è¦çš„éƒ¨åˆ† */
static char *
parse_owner(token)
  char *token;
{
  char *ptr;

  /* =?big5?B?qHSyzrresnqt+w==?= <postmaster@mail86.yzu.edu.tw> */

  ptr = strchr(token,'>'); /* > */
  if(ptr) /* çœ‹æœ€å¾Œä¸€å€‹å­—å…ƒæ˜¯å¦ç‚º > */
  {
    *ptr = 0; /*  */
    ptr = strchr(token, '<'); /* <postmaster@mail86.yzu.edu.tw */
    if(ptr[-1] == ' ')
      ptr[-1] = 0; /* <postmaster@mail86.yzu.edu.tw */
    *ptr++ = 0; /* postmaster@mail86.yzu.edu.tw */
    pop3_mime_transfer(ptr);
  }
  else /* statue.bbs@cnpa-6.admin.yzu.edu.tw */
    ptr = token;

  return ptr;
}

static char *
parse_nick(token)
  char *token;
{
  char *ptr;

  /* =?big5?B?qHSyzrresnqt+w==?= <postmaster@mail86.yzu.edu.tw> */

  ptr = token;
  if(*ptr == '=')
  {
    ptr = strchr(token, '<'); /* <postmaster@mail86.yzu.edu.tw> */
    if(ptr[-1] == ' ');
      ptr[-1] = 0; /* <postmaster@mail86.yzu.edu.tw> */
  }
  return token; /* =?big5?B?qHSyzrresnqt+w==?= */
}

/* å¾ header å–å‡ºéœ€è¦çš„éƒ¨åˆ† */
static void
parse_header(hdr, count)
  HDR *hdr;
  int count;
{
  char *ptr, *token, buf[256];
  int lines;
  struct tm tmdate;

  lines = -1;
  fprintf(fsock, "TOP %d 0\r\n", count);

  fgets(buf, 256, fsock);

  while(strncmp(buf, ".", 1))
  {
    /* ä½œè€… */
    if(!strncmp(buf, "From: ", strlen("From: ")))
    {
      char tmp[256];
      token = ptr = buf + strlen("From: ");
      strcpy(tmp,token);
      buf[strlen(buf)-2] = 0;
      tmp[strlen(tmp)-2] = 0;

      /* è¦ä¸è¦ is_base64 | is_qb */
      snprintf(hdr->nick, 48, "%s", pop3_mime_transfer(parse_nick(token)));
      /* ä¾†æºéœ€å–å‡ºåªéœ€è¦çš„éƒ¨åˆ† <s874070@mail.yzu.edu.tw> */
      hdr->nick[48] = 0;

      snprintf(hdr->owner, 78, "%s", pop3_mime_transfer(parse_owner(tmp)));
      hdr->owner[78] = 0;
    }

    /* æ—¥æœŸ */
    /* Date: Sun, 26 Dec 1999 02:07:46 -0800 */
    /* Date: 04 Jul 2000 07:18:54 GMT */
    if(!strncmp(buf, "Date: ", strlen("Date: ")))
    {
      token = ptr = buf + strlen("Date: ");
      buf[strlen(buf)-2] = 0;

      if(!strstr(token, "GMT"))
        token += 5;
      strptime(token, "%d %b %Y", &tmdate);
//      strptime(token, "%a, %d %b %Y", &tmdate);
      snprintf(hdr->date, 9, "%02d/%02d/%02d",
               (tmdate.tm_year)%100, tmdate.tm_mon+1, tmdate.tm_mday);
    }

    /* æ¨™é¡Œ */
    /* Subject: xxxxxx */
    if(!strncmp(buf, "Subject: ", strlen("Subject: ")))
    {
      token = ptr = buf + strlen("Subject: ");
      buf[strlen(buf)-2] = 0;
      pop3_mime_transfer(ptr);
      strncpy(hdr->title, ptr, 72);
      hdr->title[72] = 0;
    }

    fgets(buf, 256, fsock);
    lines++;
  }
  hdr->xid = lines;
}

static int
pop3_load_dir()
{
  char buf[256],tmp[80];
  int total = 0, step = 0, begin = 1, count;
  HDR hdr;
/*  int totalsize;*/

  fprintf(fsock, "STAT\r\n");
  fgets(buf, 256, fsock); /* +OK 14 63665 */
  if(!strncmp(buf, "+OK", 3))
  {
        total = atoi(buf+4);
/*        count = int_len(total);
        totalsize = atoi(buf+4+count);
        sprintf(tmp,"ä¿¡ä»¶ï¼š%d å°ï¼Œå…± %d bytes", total, totalsize);
        vmsg(tmp);*/
        if(total == 0)
        {
          vmsg("æ‚¨çš„é›»å­éƒµä»¶ä¿¡ç®±æ²’æœ‰ä¿¡ä»¶ã€‚");
          return 1;
        }
        else
          begin = 1;
  }
  else
    return 1;

  sprintf(tmp, "mailservice/%s.DIR", cuser.userid); /* DIRECTORY/MBOX */
  unlink(tmp);
  if((step = open(tmp, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0)
    return 1;
  for(count = begin; count <= total; count++)
  {
    hdr.xmode = MAIL_READ;
    hdr.chrono = count;
    snprintf(hdr.xname, 32, "%s.mail", cuser.userid);
    parse_header(&hdr, count); // è§£è­¯ header
    write(step, &hdr, sizeof(HDR)); /* hdr to file */
  }
  close(step);
  return 0;
}


static int
chkpop3(hdr)
  HDR *hdr;
{
  return (hdr->xmode & MAIL_MARKED);
}


static int
vfypop3(hdr, pos)
  HDR *hdr;
  int pos;
{
  return (Tagger(hdr->chrono, pos, TAG_NIN) || chkpop3(hdr));
}


static void
delpop3(xo, hdr)
  XO *xo;
  HDR *hdr;
{
  char fpath[64];

  hdr_fpath(fpath, xo->dir, hdr);
  unlink(fpath);
}


static int
pop3_rangedel(xo)
  XO *xo;
{
  return xo_rangedel(xo, sizeof(HDR), chkpop3, delpop3);
}

static int
pop3_delete(xo)
  XO *xo;
{
  int pos;
  HDR *hdr;
  char fpath[64], *dir;

  pos = xo->pos;
  hdr = (HDR *) xo_pool + (pos - xo->top);

  if (hdr->xmode & MAIL_MARKED)
    return XO_NONE;

  if (vans(msg_del_ny) == 'y')
  {
    dir = xo->dir;
    currchrono = hdr->chrono;
    if (!rec_del(dir, sizeof(HDR), pos, cmpchrono))
    {
      hdr_fpath(fpath, dir, hdr);
      unlink(fpath);
      return XO_LOAD;
    }
  }
  return XO_FOOT;
}


static int
pop3_get(fpath,hdr)
  char *fpath;
  HDR *hdr;
{
  char mail[80], buf[256] , *ptr ,*end;
  int start, totalsize,count,ck,page;
  int check_size;
  FILE *fp;
  snprintf(hdr->xname, 32, "%s.mail", cuser.userid);
  sprintf(mail, "mailservice/%s.mail", cuser.userid);

  fp = fopen(mail, "w");

  /* GET SIZE*/
  fprintf(fsock, "LIST %d\r\n", (int)hdr->chrono);
  fgets(buf, 256, fsock);
  totalsize = atoi(buf+5+int_len(hdr->chrono));

  if(totalsize > 10485760)
  {
    fprintf(fp, "\nä¿¡ä»¶å®¹é‡å¤ªå¤§ï¼Œç„¡æ³•æ”¶å–ã€‚\n");
    fclose(fp);
    return 0;
  }
  count = hdr->xid;

  if(!is_bbsmail)
  {
    fprintf(fp, "ä½œè€…: %s\n", hdr->owner); /* æŠŠ From æ”¹æˆ ä½œè€… */
    fprintf(fp, "æ¨™é¡Œ: %s\n", hdr->title);
    fprintf(fp, "æ™‚é–“: %s\n\n", hdr->date);
  }

  /* GET BODY */

  fprintf(fsock, "RETR %d\r\n", (int)hdr->chrono);
  fgets(buf, 256, fsock);

  start = is_bbsmail ? -1 : 1;

  page = 0;
  is_qp = hdr->xmode & MIME_QP;
  is_base64 = hdr->xmode & MIME_BASE64;

  fgets(buf, 256, fsock);
  totalsize = 0;
  boundary[0] = 0;
  page = 1;
  check_size = 0;
  do
  {
    start++;
    ck = pop3_mime_cut(buf, hdr, fp,fsock);
    if(start < count && *boundary == 0 && (ptr = strstr(buf,"boundary")))
    {
      ptr = strchr(buf,'"');
      end = strchr(ptr+1,'"');
      *end = 0;
      strcpy(boundary,ptr+1);
    }
    }
    if(ck == -1)
    {
      page = 1;
      hdr->xmode &= ~MIME_MIME;
    }

    is_qp = hdr->xmode & MIME_QP;
    is_base64 = hdr->xmode & MIME_BASE64;
    if(start >= count && page == 1 && ck == 1 && !check_size)
    {
      pop3_mime_transfer(buf);
      fprintf(fp, "%s", buf);
      totalsize += strlen(buf);
      if(totalsize > 10485760)
      {
        fprintf(fp, "\nä¿¡ä»¶å®¹é‡å¤ªå¤§ï¼Œç„¡æ³•æ”¶å–ã€‚\n");
        check_size = 1;
      }
    }
    ptr = fgets(buf, 256, fsock);
  } while(strcmp(buf, ".\r\n") && ptr);
  if((hdr->xmode & (MIME_BASE64|MIME_QP)) && is_mime)
  {
    fprintf(fp, "\n**é€™æ˜¯ä¸€å°ç¶“é MIME è§£ç¢¼çš„æ–‡ä»¶ï¼Œå¦‚æœ‰å•é¡Œè«‹é€šçŸ¥ç³»çµ±ç®¡ç†è€…ã€‚**
\n");
  }
  fclose(fp);
  return 1;
}

static int
pop3_browse(xo)
  XO *xo;
{
  char  file[32];
  HDR *hdr;


  hdr = (HDR *) xo_pool + (xo->pos - xo->top);

  sprintf(file, "mailservice/%s.mail", cuser.userid);


  if(!pop3_get(file, hdr))
    return XO_NONE;

  strncpy(currtitle, hdr->title, 40); /* title åªå–ç”¨å‰ 40 å€‹ ? */

  more(file, NULL);
  hdr->xmode |= MAIL_READ;

  return XO_HEAD;
}

static inline int
mbox_attr(type)
  int type;
{
  if (type & MAIL_DELETE)
    return 'D';

  if (type & MAIL_REPLIED)
    return (type & MAIL_MARKED) ? 'R' : 'r';

  return "+ Mm"[type & 3];
}

static int
pop3_tag(xo)
  XO *xo;
{
  HDR *hdr;
  int tag, pos, cur;

  pos = xo->pos;
  cur = pos - xo->top;
  hdr = (HDR *) xo_pool + cur;

  if (tag = Tagger(hdr->chrono, pos, TAG_TOGGLE))
  {
    move(3 + cur, 7);
    outc(tag > 0 ? '*' : ' ');
  }
  return xo->pos + 1 + XO_MOVE;
}

static int
pop3_prune(xo)
  XO *xo;
{
  return xo_prune(xo, sizeof(HDR), vfypop3, delpop3);
}

static int
pop3_mime_change()
{
  is_mime ^= 1;
  return XO_HEAD;
}

static int
pop3_mark(xo)
  XO *xo;
{
  HDR *mhdr;
  int cur, pos;

  pos = xo->pos;
  cur = pos - xo->top;
  mhdr = (HDR *) xo_pool + cur;
  move(3 + cur, 6);
  outc(mbox_attr(mhdr->xmode ^= MAIL_MARKED));
  rec_put(xo->dir, mhdr, sizeof(HDR), pos, NULL);
  return XO_NONE;
}

static void
pop3_item(pos, hdr)
  int pos;
  HDR *hdr;
{
#ifdef OVERDUE_MAILDEL
  int xmode;

  xmode = hdr->xmode;
  prints(xmode & MAIL_DELETE ? "%6d%c\033[1;5;37;41m%c\033[m " : "%6d%c%c ",
    pos, tag_char(hdr->chrono), mbox_attr(xmode));
#else
  prints("%6d%c%c ", pos, tag_char(hdr->chrono), mbox_attr(hdr->xmode));
#endif

  hdr_outs(hdr, 47);
}


#ifdef HAVE_LIGHTBAR
static int
pop3_item_bar(xo, mode)
  XO *xo;                       /* sequence number */
  int mode;
{
  HDR *hdr;

  hdr = (HDR *) xo_pool + xo->pos - xo->top;

#ifdef OVERDUE_MAILDEL
  int xmode;

  xmode = hdr->xmode;
  prints(xmode & MAIL_DELETE ? mode ?
    "\033[1;44m%6d%c\033[5;37;41m%c\033[0;1;44m " : "%6d%c\033[1;5;37;41m%c\033
[m " : mode ? "\
033[1;44m%6d%c%c " : "%6d%c%c ", xo->pos + 1, tag_char(hdr->chrono), mbox_attr(
xmode));

#else
  prints("%s%6d%c%c ", mode ? "\033[1;44m" : "", xo->pos + 1,
         tag_char(hdr->chrono), mbox_attr(hdr->xmode));
#endif

  if (mode)
    hdr_outs_bar(hdr, 47);
  else
    hdr_outs(hdr, 47);

  return XO_NONE;
}
#endif


static int
pop3_body(xo)
  XO *xo;
{
  HDR *pop3;
  int num, max, tail;

  max = xo->max;

  if (max <= 0)
  {
    vmsg("æ‚¨çš„é›»å­éƒµä»¶ä¿¡ç®±æ²’æœ‰ä¿¡ä»¶ã€‚");
    return XO_QUIT;
  }

  pop3 = (HDR *) xo_pool;
  num = xo->top;
  tail = num + XO_TALL;
  if (max > tail)
    max = tail;

  move(3, 0);
  do
  {
    pop3_item(++num, pop3++);
  } while (num < max);
  clrtobot();

  return XO_FOOT;
}

static int
pop3_head(xo)
  XO *xo;
{
  vs_head("Pop3æœå‹™", str_site);
  outs("[â†]é›¢é–‹ [â†’,r]è®€ä¿¡ [d]åˆªé™¤/æ•‘å› [S]é‡è®€ [R]å›ä¿¡ [x]è½‰é” [h]èªªæ˜");
  if(is_mime)
    outs(" [MIME è§£ç¢¼]");
  else
    outs(" [ ç„¡  è§£ç¢¼]");
  outs("\n\033[44m\
  ç·¨è™Ÿ   æ—¥ æœŸ ä½œ è€…        ä¿¡  ä»¶  æ¨™  é¡Œ                                  \03
3[m");

  return pop3_body(xo);
}

static int
pop3_load(xo)
  XO *xo;
{
  xo_load(xo, sizeof(HDR));
  return pop3_body(xo);
}

static int
pop3_init(xo)
  XO *xo;
{
  xo_load(xo, sizeof(HDR));
  return pop3_head(xo);
}

static int
pop3_help(xo)
  XO *xo;
{
  vmsg("æ‡¶å¾—å¯« :p");
  return XO_FOOT;
}

static int
pop3_send(xo)
  XO *xo;
{
  m_send();
  return pop3_head(xo);
}

static int
pop3_reply(xo)
  XO *xo;
{
  HDR *hdr;

  hdr = (HDR *) xo_pool + (xo->pos - xo->top);

  sprintf(quote_file,"mailservice/%s.mail",cuser.userid);
  if(!pop3_get(quote_file,hdr))
    return XO_NONE;

  do_mreply(hdr);
  return XO_HEAD;
}

static int
pop3_forward(xo)
  XO *xo;
{
  HDR *hdr,mhdr;
  char fpath[80],rcpt[64],folder[128];
  int userno;

  hdr = (HDR *) xo_pool + (xo->pos - xo->top);
  strcpy(rcpt,cuser.email);
  sprintf(fpath,"mailservice/%s.mail",cuser.userid);
  if(!pop3_get(fpath,hdr))
    return XO_NONE;
  if (!vget(b_lines, 0, "ç›®çš„åœ°ï¼š", rcpt, sizeof(rcpt), GCARRY))
    return XO_FOOT;

  if (mail_external(rcpt))
    bsmtp(fpath, hdr->title, rcpt, 0);
  else
  {
     if ((userno = acct_userno(rcpt)) <= 0)
        return -1;
     usr_fpath(folder, rcpt, fn_dir);
     hdr_stamp(folder, HDR_LINK, &mhdr, fpath);
     strcpy(mhdr.owner, cuser.userid);
     strcpy(mhdr.nick, cuser.username);
     strcpy(mhdr.title, hdr->title);
     rec_add(folder, &mhdr, sizeof(mhdr));
     m_biff(userno);
  }
  return XO_HEAD;

}

static int
pop3_reload_dir(xo)
  XO *xo;
{
  char buf[128];
  fprintf(fsock,"RSET\r\n");

  do
  {
    fgets(buf,128,fsock);
  } while (strncmp(buf,"+OK",3));

  if(pop3_load_dir())
  {
    fclose(fsock);
    vmsg("é‡è®€å¤±æ•—");
    return XO_QUIT;
  }
  del_num = 0; /* é‡è¨­å·²åˆªé™¤æ–‡ç« ç‚º 1 */
  return XO_INIT;
}

static int
pop3_mailsize(xo)
  XO *xo;
{
  char buf[128],msg[128],*str;
  HDR *hdr;
  int total,totalsize;

  hdr = (HDR *) xo_pool + (xo->pos - xo->top);
  fprintf(fsock,"LIST %d\r\n",xo->pos+1);

  do
  {
    str = fgets(buf,128,fsock);
  } while (strncmp(buf,"+OK",3) && str);

  if(str)
  {
    str = strchr(buf,' ');
    total = atoi(str);
    str = strchr(str+1,' ');
    totalsize = atoi(str);
    sprintf(msg,"ä¿¡ä»¶ï¼šç¬¬ %d å°ï¼Œå…± %d bytes", total, totalsize);
    vmsg(msg);
  }
  else
    return XO_HEAD;

  return XO_INIT;
}

static int
pop3_stat(xo)
  XO *xo;
{
  char buf[128],msg[128],*str;
  int total,totalsize;
  fprintf(fsock,"STAT\r\n");

  do
  {
    str = fgets(buf,128,fsock);
  } while (strncmp(buf,"+OK",3) && str);

  if(str)
  {
    str = strchr(buf,' ');
    total = atoi(str);
    str = strchr(str+1,' ');
    totalsize = atoi(str);
    sprintf(msg,"ä¿¡ä»¶ï¼š%d å°ï¼Œå…± %d bytes", total, totalsize);
    vmsg(msg);
  }
  else
    return XO_HEAD;

  return XO_INIT;
}

KeyFunc pop3_cb[] =
{
#ifdef HAVE_LIGHTBAR
  XO_ITEM, pop3_item_bar,
#endif
  XO_INIT, pop3_init,
  XO_LOAD, pop3_load,
  XO_HEAD, pop3_head,
  XO_BODY, pop3_body,
  'r', pop3_browse,
  'd', pop3_delete,
  'R', pop3_reply,
  'y', pop3_reply,
  's', pop3_send,
  'C', pop3_stat,
  'c', pop3_mailsize,
  't', pop3_tag,
  'S', pop3_reload_dir,
  'x', pop3_forward,
  'm', pop3_mark,
  'M', pop3_mime_change,
  Ctrl('D'), pop3_prune,
  'D', pop3_rangedel,
  'h', pop3_help
};

static int
server_login(inputemail)
  char *inputemail;
{
  char buf[256], user[60], email[60], pass[20], *host;
  int sock = 110; /* pop3 port */

  more(FN_ETC_MAILSERVICE, (char *)-1);

  if(inputemail)
    strcpy(email,inputemail);
  else
    strcpy(email,cuser.email); /* è‡ªå‹•å¹« user åŠ ä¸Šå¸³è™Ÿå */

  pass[0] = 0;
  if(!vget(21, 0, "å¸³è™Ÿï¼š", email, 60, GCARRY) ||
     !vget(22, 0, "å¯†ç¢¼ï¼š", pass, 20, NOECHO))
  {                                             /* æœ‰ä¸€é …æ²’è¼¸å…¥å‰‡æ”¾æ£„ */
    return -1;
  }

  if(!strchr(email, '@'))
  {
    vmsg("è¼¸å…¥å¸³è™Ÿæœ‰èª¤");
    return 1;
  }

  strcpy(user, email);
  *(strchr(user,'@')) = 0;
  host = strchr(email, '@')+1;

  if(Get_Socket(host, &sock))
  {
    vmsg("ä¸»æ©Ÿç„¡æ³•é€£ç·š");
    return 1;
  }

  fsock = fdopen(sock, "r+");
  fgets(buf, 256, fsock);               /* Welcome */
  fprintf(fsock, "USER %s\r\n", user);  /* USER NAME */
  fgets(buf, 256, fsock);

  if(!strncmp(buf, "+OK", 3))
  {
    is_bbsmail = strstr(buf,".bbs@") ? 1 : 0;
    fprintf(fsock,"PASS %s\r\n", pass);   /* PASSWORD */
    fgets(buf, 256, fsock);
    if(strncmp(buf, "+OK", 3))
    {
      logitfile(FN_MAILSERVICE_LOG, "-pop3  NO-", email);       /* ç™»å…¥å¤±æ•—è¨˜éŒ„
 */
      vmsg("ç™»å…¥å¤±æ•—, å¯†ç¢¼éŒ¯èª¤.");
      fclose(fsock);
      return 1;
    }
    else
    {
      logitfile(FN_MAILSERVICE_LOG, "-pop3  OK-", email);       /* ç™»å…¥æˆåŠŸè¨˜éŒ„
 */
    }
  }
  else
  {
    logitfile(FN_MAILSERVICE_LOG, "-pop3  NO-", email);       /* ç™»å…¥å¤±æ•—è¨˜éŒ„ *
/
    vmsg("ç™»å…¥å¤±æ•—, ç„¡æ­¤å¸³è™Ÿ.");
    fclose(fsock);
    return 1;
  }

  if(pop3_load_dir())
  {
    fclose(fsock);
    return 1;
  }
  return 0;
}

static int
server_logout(xo)
  XO *xo;
{
  if (del_num && vans(msg_del_ny) == 'y')
  {
    int fd;
    HDR hdr;
    char buf[200];

    if ((fd = open(xo->dir, O_RDONLY)) >= 0)
    {
      while (read(fd, &hdr, sizeof(hdr)) == sizeof(HDR))
      {
        if (hdr.xmode & POST_DELETE)
        {
          fprintf(fsock, "DELE %d\r\n", hdr.chrono);
          while (1)
          {
            if (!strncmp(fgets(buf, 200, fsock), "+OK", 3))/* purge messages */
              break;
          }
        }
      }
      close(fd);
    }
  }
  fprintf(fsock, "QUIT\r\n");
  fclose(fsock);
  return 0;
}

int
Pop3mail()
{
  XO *xo;
  char currsmaildir[30];

  del_num = is_base64 = is_qp = 0; /* é è¨­å·²åˆªé™¤æ–‡ç« æ•¸ç‚º 0, ç„¡è§£ç¢¼æ–¹å¼ */

  is_mime = (cuser.ufo & UFO_MIME) ? 1 : 0; /* è‹¥ç„¡ UFO_MIME å‰‡å°‡é€™è¡Œå–æ¶ˆ */

  sprintf(currsmaildir, "mailservice/%s.DIR", cuser.userid); /*DIRECTORY/MBOX*/

  /* by statue */
  if (server_login(NULL))
    return 0;

  xz[XZ_MIME - XO_ZONE].xo = xo = xo_new(currsmaildir); /* è¨­å– .DIR è·¯å¾‘ */
  xz[XZ_MIME - XO_ZONE].cb = pop3_cb;
  xover(XZ_MIME);

  server_logout(xo);

  free(xo);
  return 0;
}

int
Pop3Contact(email)
  char *email;
{
  XO *xo;
  char currsmaildir[30];

  del_num = is_base64 = is_qp = 0; /* é è¨­å·²åˆªé™¤æ–‡ç« æ•¸ç‚º 0, ç„¡è§£ç¢¼æ–¹å¼ */

  is_mime = (cuser.ufo & UFO_MIME) ? 1 : 0; /* è‹¥ç„¡ UFO_MIME å‰‡å°‡é€™è¡Œå–æ¶ˆ */

  sprintf(currsmaildir, "mailservice/%s.DIR", cuser.userid); /*DIRECTORY/MBOX*/


  if (server_login(email))
    return 0;

  xz[XZ_MIME - XO_ZONE].xo = xo = xo_new(currsmaildir); /* è¨­å– .DIR è·¯å¾‘ */
  xz[XZ_MIME - XO_ZONE].cb = pop3_cb;
  xover(XZ_MIME);

  server_logout(xo);

  free(xo);
  return 0;
}


--
[0m[1;31;44m ã€â•­â•¯[33mæˆå¤§é†«å­¸[31mâ•­â•¯ [32mâ—¥[35mâ—¢      [37mï¹Œ  â˜† [35m?[32mi[33m?[36mi [32mbbs.med.ncku.edu.tw [36m?[33mi[32m?[35mi [37mâ˜†  ï¹‹     [0m
[0m[1;31;42m â•­â•¯[33mè¿´ é¢¨ è°·[31mâ•­â•¯ã€ [31mâ—¤[34mâ—£ [37mâ†’Fromï¼š[36mbackwind.g1.dorm.ncku.edu.tw               [37mâ†[0m
