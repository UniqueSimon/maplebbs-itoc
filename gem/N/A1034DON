ç™¼ä¿¡äºº: amaki.bbs@luna.twbbs.org (å·§å…‹åŠ›ç¾Š) çœ‹æ¿: plan
æ¨™  é¡Œ: [åŠŸèƒ½]çœ‹æ¿ç²¾è¯å€æ’è¡Œæ¦œ
ç™¼ä¿¡ç«™: æœˆä¸‹å¤œæƒ³ (2004/01/02 Fri 22:58:57)                Updated: 2004/01/02

  è½èªªä¸å°‘ç«™å°æœ‰é€™æ±è¥¿ï¼Œå¯«å¯«ç•¶æ–°å¹´ç¦®ç‰©å§ã€‚

  ç«™é•·å…ˆåœ¨Announceè£¡æ–°å¢è³‡æ–™ï¼Œæª”åç‚º@-topgem

  util/ä¸‹æ–°å¢é€™æ”¯topgemsize.c

  crontab -eè¨­å€‹å®šæœŸè·‘çš„æ™‚é–“å°±å¯ä»¥äº†ã€‚

  å¦å¤–é€™æ”¯ç¨‹å¼è£¡æœ‰å€‹node()ï¼Œè£¡é¢çš„4094è·Ÿ1024å€‹åˆ¥æ˜¯æˆ‘çš„ç¡¬ç¢Ÿåˆå§‹åŒ–æ™‚çš„blockè·Ÿ

  fragmentå¤§å°ï¼Œé€™åªèƒ½ç®—å‡ºæ¯”è¼ƒæ¥è¿‘çš„inodeæ•¸(ä¸€å€‹inodeä½”å»128 bytes)ï¼Œå¦‚æœä½ çš„

  æ¯”ä¾‹ä¸æ˜¯4096 / 1024è«‹èª¿æ•´æˆè‡ªå·±ç¡¬ç¢Ÿçš„åƒæ•¸ã€‚

: src/util/Makefile

EXE =   ... [1;33mtopgemsize[m

: topgemsize.c

/*-------------------------------------------------------*/
/* util/topgemsize.c    ( NTHU CS MapleBBS Ver 3.10 )    */
/*-------------------------------------------------------*/
/* target : çœ‹æ¿ç²¾è¯å€å€æ’è¡Œæ¦œ                           */
/* create : 04/01/02                                     */
/* author : amaki.bbs@luna.twbbs.org                     */
/*-------------------------------------------------------*/


#include "bbs.h"

#define TOPGEM  "gem/@/@-topgem"

typedef struct
{
  int year;
  int yday;
  int mon;
  int mday;
  int wday;
  int hour;
} DATE;


typedef struct
{
  int bno;
  int dir_nums;
  int file_nums;
  int gsize;
} BGEM;


static BCACHE *bshm;
static BGEM *bgem;


static int
node(size)
  int size;
{
  int node, frag;

  node = (size / 4096) * 128;
  node += (frag = (size % 4096) / 1024) ? frag * 128 : 0;

  return node;
}


static void
gem_folder(folder, gem_set)
  char *folder;
  BGEM *gem_set;
{
  int fd, count, dnum;
  char fpath[64];
  HDR *xt, *hdr;
  struct stat st;

  if ((fd = open(folder, O_RDONLY)) < 0)
    return;

  fstat(fd, &st);
  hdr = xt = (HDR *) malloc(count = st.st_size);
  count = read(fd, xt, count) / sizeof(HDR);
  close(fd);

  do
  {
    hdr_fpath(fpath, folder, hdr);

    if (hdr->xmode & GEM_FOLDER)
    {
      gem_set->dir_nums++;
      if (dnum = rec_num(fpath, sizeof(HDR)) > 0)
      {
        gem_set->file_nums++;
        gem_set->gsize += dnum * sizeof(HDR) + node(dnum * sizeof(HDR));
        gem_folder(fpath, gem_set);
      }
    }
    else if (dashf(fpath))
    {
      stat(fpath, &st);
      gem_set->file_nums++;
      gem_set->gsize += st.st_size + node(st.st_size);
    }
  } while (++hdr < xt + count);

  free(xt);
}


static void
gem_counter(brd, gem_set)
  BRD *brd;
  BGEM *gem_set;
{
  int fd, count, dnum;
  char fpath[64], folder[64];
  HDR *xt, *hdr;
  struct stat st;

  sprintf(folder, "gem/brd/%s/%s", brd->brdname, FN_DIR);

  if ((fd = open(folder, O_RDONLY)) < 0)
    return;

  fstat(fd, &st);
  hdr = xt = (HDR *) malloc(count = st.st_size);
  count = read(fd, xt, count) / sizeof(HDR);
  close(fd);

  do
  {
    hdr_fpath(fpath, folder, hdr);

    if (hdr->xmode & GEM_FOLDER)
    {
      gem_set->dir_nums++;
      if (dnum = rec_num(fpath, sizeof(HDR)) > 0)
      {
        gem_set->file_nums++;
        gem_set->gsize += dnum * sizeof(HDR) + node(dnum * sizeof(HDR));
        gem_folder(fpath, gem_set);
      }
    }
    else if (dashf(fpath))
    {
      stat(fpath, &st);
      gem_set->file_nums++;
      gem_set->gsize += st.st_size + node(st.st_size);
    }
  } while (++hdr < xt + count);

  free(xt);
}


static void
gem_record(date)
  DATE *date;
{
  int ansi, i = 0;
  BRD *brd;
  BGEM *bgem_set;
  FILE *fp;
  char msg[80], dbuf[16], anony[16];

  if (!(fp = fopen(TOPGEM, "w")))
    return;

  sprintf(msg, "%dæœˆ%dæ—¥çœ‹æ¿ç²¾è¯å€æ’è¡Œ", date->mon, date->mday);

  fprintf(fp, "\033[1;35;47m%*s%*s",
    41 + strlen(msg) / 2, msg, 41 - strlen(msg) / 2, "\033[m\n");
 fprintf(fp, "\033[1;37;45mã€æ’  åã€‘  ã€çœ‹    æ¿ã€‘  ã€æª”æ¡ˆæ•¸ã€‘  ã€ç›®éŒ„æ•¸ã€‘"
   "  ã€ç¸½ç²¾è¯å€å¤§å°(bytes)ã€‘     \033[m\n");

  do
  {
    ansi = 0;
    bgem_set = bgem + i;
    brd = bshm->bcache + bgem_set->bno;
    sprintf(dbuf, "%d.", i + 1);
    sprintf(anony, "%c%s", brd->brdname[0], "â—‹â—‹â—‹â—‹");

    if (i < 5)
    {
      fprintf(fp, "  \033[1m%-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
      ansi = 1;
    }
    else if (i < 9)
    {
      fprintf(fp, "  \033[1;33m%-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
      ansi = 1;
    }
    else
    {
      fprintf(fp, "  %-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
    }

    if (bgem_set->gsize > 1048576)
      fprintf(fp, "(%dMB)%s\n", bgem_set->gsize / 1048576, ansi ? "\033[m":"");
    else if (bgem_set->gsize > 1024)
      fprintf(fp, "(%dKB)%s\n", bgem_set->gsize / 1024, ansi ? "\033[m" : "");
    else
      fprintf(fp, ansi ? "\033[m\n" : "\n");
  } while (++i < bshm->number);

  fclose(fp);
}


static int
bgem_cmp(a, b)
  BGEM *a, *b;
{
  return b->gsize - a->gsize;
}


int
main()
{
  int i;
  BRD *brd;
  DATE now;
  BGEM *gem_set;
  time_t time_now;
  struct tm *t;

  chdir(BBSHOME);

  bshm = shm_new(BRDSHM_KEY, sizeof(BCACHE));
  bgem = (BGEM *) malloc(sizeof(BGEM) * bshm->number);
  memset(bgem, 0, sizeof(BGEM) * bshm->number);

  time(&time_now);
  time_now -= 400;
  t = localtime(&time_now);
  now.year = t->tm_year;
  now.yday = t->tm_yday;
  now.mon = t->tm_mon + 1;
  now.mday = t->tm_mday;
  now.wday = t->tm_wday;
  now.hour = t->tm_hour;

  for (i = 0; i < bshm->number; i++)
  {
    brd = bshm->bcache + i;
    gem_set = bgem + i;
    /* amaki.030730: é–‹å•Ÿçœ‹æ¿ç›®éŒ„ä¸‹çš„bdata */
    if (*brd->brdname)
    {
      gem_set->bno = i;
      gem_counter(brd, gem_set);
    }
  }

  qsort(bgem, bshm->number, sizeof(BGEM), bgem_cmp);

  gem_record(&now);

  free(bgem);
  return 0;
}

--
  [1;33mOrigin: luna.twbbs.org[m
